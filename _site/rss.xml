<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>Youly</title>
        <description>Youly - Youly</description>
        <link>http://youly.github.io</link>
        <link>http://youly.github.io</link>
        <lastBuildDate>2017-10-19T14:38:07+08:00</lastBuildDate>
        <pubDate>2017-10-19T14:38:07+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>从线上lock wait timeout报错看mysql锁设计</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;问题&lt;/h3&gt;
&lt;p&gt;最近监控邮件报告某个接口超时比较多，查看错误日志发现偶尔会有类似下面的记录：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Exception occurs while doing  org.springframework.dao.CannotAcquireLockException:
### Error updating database.  Cause: java.sql.SQLException: Lock wait timeout exceeded; try restarting transaction
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;刚开始怀疑不是这个报错导致的，因为最近也没有上线，问了dba说数据库也没发现死锁异常，查看相关代码，事务包含的业务逻辑比较简单，看起来也不会出现比较耗时的操作。只是怀疑，于是关闭了某个可疑功能的开关，观察了几个小时，发现此类错误日志有所减少，但仍然有。想起前些天在线上跑官方账号粉丝数据，也是和这个功能相关，因此大概确定了问题：原本不大的表，因跑官方账号数据的任务短时间内插入了大量数据，虽然此表有建索引，但由于是一个账号有大量粉丝，执行更新的sql语句仍然要查找很多数据，导致这条sql执行时间长，又因为是在事务中，当前线程持有相关锁，导致其他线程无法获取相关锁而超时。&lt;/p&gt;

&lt;p&gt;解决方法很简单，找dba优化下索引就行了。确实加完索引后，报错日志没有了，但有一个问题还没搞清楚，这里的相关锁是什么？&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;复现&lt;/h3&gt;

&lt;p&gt;在本机搭建mysql server环境，存储引擎默认 innodb，其他信息如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; select version();
+------------+
| version()  |
+------------+
| 5.6.24-log |
+------------+

mysql&amp;gt; show variables like 'innodb_locks_unsafe_for_binlog';
+--------------------------------+-------+
| Variable_name                  | Value |
+--------------------------------+-------+
| innodb_locks_unsafe_for_binlog | OFF   |
+--------------------------------+-------+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;假设使用如下表结构进行模拟：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE `tb` (
 `id` bigint(20) unsigned NOT NULL,
 `name` varchar(128) NOT NULL DEFAULT '',
 `tag` varchar(128) NOT NULL DEFAULT '',
 PRIMARY KEY (`id`),
 KEY `idx_name` (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4

-- 初始化数据
insert into tb values (1,'a','t1');
insert into tb values (2,'b', 't2');
insert into tb values (3,'c', 't3');
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;来看一下几种情况：&lt;/strong&gt;&lt;/p&gt;

&lt;h5 id=&quot;scene1&quot;&gt;scene1&lt;/h5&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;session1&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;session2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;mysql&amp;gt; begin;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;mysql&amp;gt; begin;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;mysql&amp;gt; update tb set tag = ‘t’ where name = ‘c’;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Query OK, 1 row affected (0.01 sec)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;mysql&amp;gt; insert into tb values (4,’d’, ‘t4’);&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;查看当前有哪些锁等待：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; select * from information_schema.innodb_lock_waits;
+-------------------+-------------------+-----------------+------------------+
| requesting_trx_id | requested_lock_id | blocking_trx_id | blocking_lock_id |
+-------------------+-------------------+-----------------+------------------+
| 9406882           | 9406882:8712:4:1  | 9406881         | 9406881:8712:4:1 |
+-------------------+-------------------+-----------------+------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看出，事务9406882在等待事务9406881释放锁，锁信息如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; select * from information_schema.innodb_locks\G
*************************** 1. row ***************************
    lock_id: 9406882:8712:4:1
lock_trx_id: 9406882
  lock_mode: X
  lock_type: RECORD
 lock_table: `test`.`tb`
 lock_index: idx_name
 lock_space: 8712
  lock_page: 4
   lock_rec: 1
  lock_data: supremum pseudo-record
*************************** 2. row ***************************
    lock_id: 9406881:8712:4:1
lock_trx_id: 9406881
  lock_mode: X
  lock_type: RECORD
 lock_table: `test`.`tb`
 lock_index: idx_name
 lock_space: 8712
  lock_page: 4
   lock_rec: 1
  lock_data: supremum pseudo-record
2 rows in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;scene2&quot;&gt;scene2&lt;/h5&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;session1&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;session2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;mysql&amp;gt; begin;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;mysql&amp;gt; begin;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;mysql&amp;gt; update tb set tag = ‘t’ where name = ‘b’;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Query OK, 1 row affected (0.01 sec)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;mysql&amp;gt; insert into tb values (4,’d’, ‘t4’);&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Query OK, 1 row affected (0.01 sec)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h5 id=&quot;scene3&quot;&gt;scene3&lt;/h5&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;session1&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;session2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;mysql&amp;gt; begin;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;mysql&amp;gt; begin;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;mysql&amp;gt; update tb set tag = ‘t’ where id = 3;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Query OK, 1 row affected (0.01 sec)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;mysql&amp;gt; insert into tb values (4,’d’, ‘t4’);&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Query OK, 1 row affected (0.01 sec)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;以上，scene1复现了线上的情况，对比scene2/scene3又看到了不同的情况，很惊讶吧，具体原理及解释，需要先看看mysql的锁设计。&lt;/p&gt;

&lt;h3 id=&quot;mysql-&quot;&gt;mysql 锁设计&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/lock_critical.jpg&quot; alt=&quot;lock critical&quot; /&gt;&lt;/p&gt;

&lt;p&gt;锁是针对并发访问相同资源而设计的，如上图。innodb引擎为了控制事务间不同级别下的隔离性，提了供不同类型不同粒度的锁，同一个sql语句加锁情况会不一样。下面具体讨论下mysql存储引擎innodb的锁，建议先阅读&lt;a href=&quot;http://hedengcheng.com/?p=771&quot;&gt;【MySQL 加锁处理分析】&lt;/a&gt;这篇文章，理解什么是快照读与当前读，二阶段锁。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;锁类型&lt;/h4&gt;

&lt;p&gt;从控制并发读写相同资源的角度来看，innodb主要有两种类型的锁，即共享锁（读锁）和排他锁（写锁）。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;共享锁，允许拿到共享锁的事务去读一行记录&lt;/li&gt;
  &lt;li&gt;排他锁，允许拿到排他锁的事务去更新或删除一行记录&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;兼容矩阵如下：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt; &lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;X&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;S&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;X&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Conflict&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Conflict&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;S&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Conflict&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Compatible&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&quot;section-3&quot;&gt;锁粒度&lt;/h4&gt;

&lt;p&gt;为提高事务并发读写数据的能力及实现数据库不同的隔离级别，innodb设计了不同粒度的锁，主要有两种：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;RECORD LOCK：行级锁，锁对象是innodb的索引记录，可以是一条记录，也可以是一个范围(gap lock, next-key lock都属于范围锁)。当待锁定记录所在表没有显式索引时，mysql把锁建立在隐藏的聚簇索引上。&lt;/li&gt;
  &lt;li&gt;TABLE LOCK：表级锁，控制表级别的并发。需要注意的是 &lt;a href=&quot;https://dev.mysql.com/doc/refman/5.5/en/innodb-locking.html#innodb-intention-locks&quot;&gt;Intention Locks 被归类为表级锁&lt;/a&gt;，但我的理解是意向锁仍然用于控制行记录并发更新，由于表变更操作会影响行记录的变更，因此需要一种新的锁来衔接表锁和行锁，于是有了意向锁，表锁释放后，唤醒持有意向锁阻塞的线程（理解不一定对，请指正）。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要特别注意的是，gap锁实现和传统意义上的锁有点不一样，gap锁的作用是防止其他线程往一个范围里插入满足条件的新纪录，gap锁之间不一定是冲突的。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;锁使用时机&lt;/h4&gt;
&lt;p&gt;innodb的这些锁什么时候被使用到？我们常见的CRUD操作，会加什么锁？如上面提到，不同隔离级别、where条件中使用不同索引，都会导致同一个sql请求获取不同的锁。&lt;/p&gt;

&lt;p&gt;另外需特别注意，被加锁的记录与where条件是否匹配并没有关系：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A locking read, an UPDATE, or a DELETE generally set record locks on every index record that is scanned in the processing of the SQL statement. It does not matter whether there are WHERE conditions in the statement that would exclude the row.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以下列举常见的几种情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;INSERT：为防止其他线程插入相同记录，会在待插入记录主键上获取排它锁；如果是rr隔离级别，会提前获取待插入记录的 intent gap lock，避免幻读。&lt;/li&gt;
  &lt;li&gt;SELECT：普通的 SELECT FROM 不会加任何锁，也会忽略任何已经加上的锁，除非是SERIALIZABLE隔离级别。SELECT FROM LOCK IN SHARE MODE 会获取共享 next-key lock，SELECT FROM FOR UPDATE 会获取排他的 next-key lock。&lt;/li&gt;
  &lt;li&gt;UPDATE：设置意向排它锁，同时针对扫描的记录，设置排他的 next-key lock。&lt;/li&gt;
  &lt;li&gt;DELETE：DELETE FROM 对扫描到的所有记录设置 next-key lock。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以上SELECT/UPDATE/DELETE，都要排除 where 条件里包含主键的情况，如果包含主键，则仅仅会锁住一条记录，而不是加 next-key lock。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;问题解释&lt;/h4&gt;
&lt;p&gt;innodb索引记录是按照B+树组织的，可参考此篇&lt;a href=&quot;http://blog.lastww.com/2015/01/05/b-tree&quot;&gt;文章&lt;/a&gt;，将上述记录按照B+数的组织方式拆分，假设拆分成如下几个范围：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;（-∞,1]，(1,2]，(2,3]，(3,+∞）
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;scene1中session2事务update语句持有了(2,3], (3, 正无穷)的next-key lock，导致session1无法获取插入意向锁而阻塞&lt;/li&gt;
  &lt;li&gt;scene2中session2事务，由于where条件包含了idx_name的非唯一性索引，update语句持有了(1, 2]，(2, 3]的next-key lock，而 session1插入的是大于3的记录，故可以插入&lt;/li&gt;
  &lt;li&gt;scene3中session2事务update语句持有了primary key = 3的行锁，不影响session1获取意向锁&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-6&quot;&gt;为避免锁超时，使用事务时的注意点&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;事务里不要包含耗时的操作，大事务转成多个小事务；涉及较耗时的io操作移到事务外进行，减少锁定的资源和时间。&lt;/li&gt;
  &lt;li&gt;尽可能让事务里的检索、更新操作使用到索引，避免innodb无法使用到索引进而锁全表。&lt;/li&gt;
  &lt;li&gt;合理设计索引，尽可能是通过索引缩小innodb的锁定范围。&lt;/li&gt;
  &lt;li&gt;尽量避免范围查询、更新操作。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-7&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.5/en/innodb-locking.html&quot;&gt;InnoDB Locking&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.6/en/innodb-locks-set.html&quot;&gt;Locks Set by Different SQL Statements in InnoDB&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;https://dbarobin.com/2015/01/27/innodb-lock-wait-under-mysql-5.5/&quot;&gt;MySQL 5.5 InnoDB 锁等待&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4、&lt;a href=&quot;http://webcache.googleusercontent.com/search?q=cache:lHzy2YgeTOwJ:hedengcheng.com/%3Fp%3D771+&amp;amp;cd=4&amp;amp;hl=zh-CN&amp;amp;ct=clnk&amp;amp;gl=hk&quot;&gt;MySQL 加锁处理分析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5、&lt;a href=&quot;http://www.cnblogs.com/kesongbing/archive/2012/09/24/2700742.html&quot;&gt;MySQL数据库InnoDB存储引擎中的锁机制&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;6、&lt;a href=&quot;https://pages.mtu.edu/~shene/NSF-3/e-Book/MUTEX/locks.html&quot;&gt;Lock Basic Concept&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://youly.github.io/2017/10/19/mysql-lock-wait-timeout</link>
                <guid>http://youly.github.io/2017/10/19/mysql-lock-wait-timeout</guid>
                <pubDate>2017-10-19T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>关于单元测试的总结及思考</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;什么是单元测试&lt;/h3&gt;

&lt;h4 id=&quot;section-1&quot;&gt;基本概念&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Unit_testing&quot;&gt;点击查看&lt;/a&gt; Wikipedia 词条，要点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;软件测试中的一种方法，验证程序运行符合预期。&lt;/li&gt;
  &lt;li&gt;将程序逻辑切分成单元或者模块，按照最小单元进行测试。面向对象设计的语言中，unit 通常是一个 class/method。&lt;/li&gt;
  &lt;li&gt;理想的 unit 具备良好的独立性，依赖以 mock/stub 的方式注入。关于stub和mock的区别，可以查看martinfowler的博客：&lt;a href=&quot;https://martinfowler.com/articles/mocksArentStubs.html&quot;&gt;Mocks Aren’t Stubs&lt;/a&gt;。&lt;/li&gt;
  &lt;li&gt;由开发人员或者白盒测试人员编写。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么如何验证程序运行是否符合预期呢？以OOP为例，对象主要由两点来描述：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;State&lt;/em&gt;，对象的状态，可以理解为某一时刻的属性值。&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Behavior&lt;/em&gt;，对象的行为，接收到外部消息后进行状态变更的过程。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unit testing 可以基于这两点来做验证，即 state assert 和 behavior verification。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;单元测试在整个测试流程中的位置&lt;/h4&gt;
&lt;p&gt;一般测试流程中有如下几个阶段，并按照时间顺序进行：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/unit-test-2.png&quot; alt=&quot;test&quot; style=&quot;height: 60px;&quot; /&gt;
&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;单元测试，由开发主导，验证基础单元/模块功能。&lt;/li&gt;
  &lt;li&gt;集成测试，和外部环境联通，验证跨单元的功能。&lt;/li&gt;
  &lt;li&gt;冒烟测试，属于端到端的测试，一般由开发主导，验证程序基本流程没问题后，再交付给测试人员进行后续测试。&lt;/li&gt;
  &lt;li&gt;回归测试，由测试主导，验证新增功能是否影响原有功能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;单元测试的价值&lt;/h3&gt;
&lt;p&gt;很多团队并不怎么看重单元测试，认为价值不大且投入精力多，这点对于具有良好质量意识的个人来说确实如此，但对于一个团队，需要更多的从管理方法上去提高整体质量。从自己写单元测试来看，我感受有以下几点价值：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;测试驱动开发，而不是前端驱动。对于纯后端开发人员，写完某个功能，不必等待前端开发完一起联调，自己写单元测试效率更高。&lt;/li&gt;
  &lt;li&gt;前人种树后人乘凉，完善的单元测试有利于后面做重构，降低了代码维护成本。&lt;/li&gt;
  &lt;li&gt;代码质量的一个度量，数据统计方便于管理做决策。&lt;/li&gt;
  &lt;li&gt;在著名的”测试金字塔”中，单元测试处于底层，相比上层的测试，单测运行快、成本低，更能指出问题所在并快速bugfix，关于这一点可以延伸阅读下：&lt;a href=&quot;https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html&quot;&gt;Google testing: Just Say No to More End-to-End Tests&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/unit-test-3.png&quot; alt=&quot;testPyramid&quot; style=&quot;width: 350px;&quot; /&gt;
&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;实施单元测试的难点&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;mock数据难，经常把单元测试写成了集成测试。&lt;/li&gt;
  &lt;li&gt;需要与发布、持续集成环境整合才能体现其主动性，需要有专门的测试开发负责推进。&lt;/li&gt;
  &lt;li&gt;并不是开发中必须有的一个流程，没有强制的衡量标准。&lt;/li&gt;
  &lt;li&gt;对于已经发展庞大但缺失单测的项目，由于代码不符合单测工具所约定的规范，再去补充单元测试很难（亲身经历），需要对项目进行拆分及规范化。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-5&quot;&gt;如何做单元测试&lt;/h3&gt;

&lt;h4 id=&quot;section-6&quot;&gt;1、制定需要遵守的规范&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;代码布局&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;src/
├── main
│   ├── java
│   └── resources
└── test
	├── java
	└── resources
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;详细请参考 &lt;a href=&quot;http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html&quot;&gt;maven工程标准结构&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;类、方法命名&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 类命名以Test结尾	&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TokenServiceTest&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AbstractTestCase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

	&lt;span class=&quot;nd&quot;&gt;@Resource&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TokenService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tokenService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

	&lt;span class=&quot;c1&quot;&gt;// 方法命名以Test结尾&lt;/span&gt;
	&lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
	&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insertTest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;MockUp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TokenDao&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tokenDaoMockUp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MockUp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TokenDao&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
			&lt;span class=&quot;nd&quot;&gt;@Mock&lt;/span&gt;
			&lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Token&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
				&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
			&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;ReflectionTestUtils&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;setField&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tokenService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;tokenDao&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tokenDaoMockUp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getMockInstance&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
		&lt;span class=&quot;n&quot;&gt;tokenService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;代码逻辑分层，良好的分层有助于更加清晰的单元测试编写，请参考上一篇文章 &lt;a href=&quot;http://blog.lastww.com/2017/07/03/web-service-layed-design&quot;&gt;Web分层设计模型&lt;/a&gt;。分层之后，每一层应该做什么？&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1) web层
验证 PATH，REQUEST_METHOD 配置是否正确，验证 RESPONSE_CODE是否正常。这一层实际上属于端到端的测试，一般项目中很难测出问题，大部分情况下可以省略。

2) facade层
验证参数校验，数据组装转换是否符合预期。

3) service/component层
验证业务逻辑、流程是否正常，需要mock掉外部服务依赖。

4) cache层
验证缓存配置是否正常，缓存读写命令是否正常，用例需要包含清理数据的逻辑。

5) dao层
验证sql逻辑是否正确，主键是否正常。如果用到测试数据库，测试完后需要回滚数据。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;与发布流程整合&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;将单元测试集成到发布流程中，只有单测单通才能进行review和提测。&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;2、选择好用的工具和框架&lt;/h4&gt;
&lt;p&gt;关于有哪些工具和框架，以及优缺点，这里就不列举了，直接推荐以下两个：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;TestNG: a testing framework inspired from JUnit and NUnit but introducing some new functionalities, 网站：http://testng.org/doc/&lt;/li&gt;
  &lt;li&gt;jmockit: includes APIs for mocking, faking, and integration testing, and a code coverage tool. 网站：http://jmockit.org/about.html。API 介绍如下：&lt;/li&gt;
&lt;/ul&gt;

&lt;p align=&quot;center&quot;&gt;
&lt;img src=&quot;/assets/images/unit-test-1.png&quot; alt=&quot;jmockit&quot; style=&quot;width: 600px;&quot; /&gt;
&lt;/p&gt;

&lt;h4 id=&quot;section-8&quot;&gt;3、定期评估&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;覆盖率指标需要保持在一个固定值之上，如果下降需要有人跟进。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-9&quot;&gt;最终，别忘了&lt;/h3&gt;
&lt;p&gt;单元测试不仅仅是开发的事，需要测试一起配合推动。&lt;/p&gt;

&lt;h3 id=&quot;section-10&quot;&gt;参考链接&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;https://martinfowler.com/bliki/TestPyramid.html&quot;&gt;Martinfowler: TestPyramid&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html&quot;&gt;Google testing: Just Say No to More End-to-End Tests&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;https://stackoverflow.com/questions/520064/what-is-unit-test-integration-test-smoke-test-regression-test&quot;&gt;What is Unit test, Integration Test, Smoke test, Regression Test?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4、&lt;a href=&quot;http://geosoft.no/development/unittesting.html&quot;&gt;Unit Testing Guidelines&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5、&lt;a href=&quot;https://martinfowler.com/articles/mocksArentStubs.html&quot;&gt;Martinfowler: Mocks Aren’t Stubs&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://youly.github.io/2017/07/07/unit-testing</link>
                <guid>http://youly.github.io/2017/07/07/unit-testing</guid>
                <pubDate>2017-07-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Web服务分层设计模型</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;引言&lt;/h3&gt;
&lt;p&gt;如何写好代码，是每个程序员都应该去关注的话题。代码不仅仅是给机器执行的，更是给人看的。我们都希望自己的代码写的好看犹如你的外表，但面对复杂业务需求和多人协同时，如果没有一套基本的原则规范，很难确保不迷失方向。本文就如何写好代码的问题，试图整理出一套规范。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;什么是分层设计&lt;/h3&gt;
&lt;p&gt;简单的理解就是，把系统的逻辑功能按照某些原则抽象出几个层次，层次内保持高类聚，层次间保持低耦合，整个系统达到概念清晰，边界清晰，最终功能稳定。&lt;/p&gt;

&lt;p&gt;分层设计在软件架构中是比较常见的，比如OSI七层网络模型、计算机系统分层模型。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/web-layer-4.png&quot; alt=&quot;osi网络分层&quot; style=&quot;width: 220px;&quot; /&gt;
&lt;img src=&quot;/assets/images/web-layer-3.jpg&quot; alt=&quot;计算机系统分层&quot; style=&quot;width: 220px;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同样的，分层设计这种思想也可以扩展到平时写的业务代码中。&lt;/p&gt;

&lt;h3 id=&quot;web&quot;&gt;Web服务分层设计模型&lt;/h3&gt;
&lt;p&gt;在讨论Web服务分层设计模型前，有必要先了解下微服务的概念，毕竟分层设计模型属于其中的一部分。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The microservice architectural style is an approach to developing a single application as a suite of small services, each running in its own process and communicating with lightweight mechanisms, often an HTTP resource API. These services are built around business capabilities and independently deployable by fully automated deployment machinery. There is a bare minimum of centralized management of these services, which may be written in different programming languages and use different data storage technologies.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上文是 &lt;a href=&quot;https://martinfowler.com/articles/microservices.html&quot;&gt;Martin Fowler&lt;/a&gt; 给 microservice 的一个解释。微服务在当下是非常流行的架构，很多公司采用，也有一些开源的框架实现。实施微服务架构有几个重要的原则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;服务化的组件，组件服务化，通过服务接口来暴露组件&lt;/li&gt;
  &lt;li&gt;按业务能力来组织划分服务&lt;/li&gt;
  &lt;li&gt;面向产品，而不是项目，团队应该为产品的整个生命周期负责。&lt;/li&gt;
  &lt;li&gt;基础设施自动化，即应用的构建、集成测试、发布自动化。&lt;/li&gt;
  &lt;li&gt;还有其他几条原则…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;微服务涉及的概念比较多，需要自己去多多阅读文档。下图是一个简单的架构描述，我们写的业务代码通常都是在其中的左侧绿色service部分：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/web-layer-1.jpg&quot; alt=&quot;常见系统架构&quot; style=&quot;width: 660px;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;针对其中的service层业务，结合实战中的经验，总结出以下分层模型：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/web-layer-2.jpg&quot; alt=&quot;常见系统架构&quot; style=&quot;width: 660px;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Vo: view object&lt;/li&gt;
  &lt;li&gt;Bo: business object&lt;/li&gt;
  &lt;li&gt;Co: cache object&lt;/li&gt;
  &lt;li&gt;Do: database object&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上层可以调用下层，下层不可调用上层，同层之间调用看情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Facade层：对外暴露的服务(dubbo)接口，调用不同的service层服务，处理vo2bo/bo2vo的数据转换，接口版本兼容处理。同层之间不可以调用。&lt;/li&gt;
  &lt;li&gt;Service层：业务领域内复杂逻辑处理(cpu计算密集型)和业务之间的数据交换，调用Component层接口获取数据。同层之间可以调用，可以越过component层调用cache、dao读接口。&lt;/li&gt;
  &lt;li&gt;Component层：相同业务域service公共逻辑下层到本层，调用cache/dao层提供的接口，最小业务处理单元，不可再拆分。相互之间不可以调用。一般业务比较简单时，可以先不实现component。业务变复杂后，根据情况把公共部分下层到component层。&lt;/li&gt;
  &lt;li&gt;Cache层：cache数据读写，包括组合的数据对象cache和单纯的dao cache，只处理缓存相关的读写，调用dao层接口填充cache。同层之间不可以调用。&lt;/li&gt;
  &lt;li&gt;Dao层：database层的数据读写，负责业务无关操作，如db更新，数据变更触发的消息推送。一个dao对应一张表。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;关于成本&lt;/h3&gt;
&lt;p&gt;实施微服务架构带来的开发/运维成本本身就比单体应用高很多，再去做分层处理，开发成本就更高了。因此对于追求业务快速上线的，没必要以这种方式去实施，但对于基础中台服务，稳定性、可维护性要求较高，此规范可做参考。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;参考链接&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://martinfowler.com/articles/microservices.html&quot;&gt;Microservices&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://youly.github.io/2017/07/03/web-service-layed-design</link>
                <guid>http://youly.github.io/2017/07/03/web-service-layed-design</guid>
                <pubDate>2017-07-03T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>技术人员也应该有产品思维</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;什么是产品思维&lt;/h3&gt;
&lt;p&gt;这个词定义太广泛了，每个人都可能有自己的见解，或深或浅。我自己的理解是，把这个词进行分解，即产品 + 思维。产品是客观存在的实体，思维是主观能动的意识，组合起来就是以实体存在的方式来指导行动前的思考。好的产品思维体现在，看到一个产品，你能马上推断到这个产品为什么存在，它的设计，它的架构，它的核心kpi。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/product-sense.png&quot; alt=&quot;产品思维&quot; style=&quot;width: 350px;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;产品思维是凭直觉的吗&lt;/h3&gt;
&lt;p&gt;当然不是，好的产品思维是通过学习获得的，需要刻意培养，实践中学习(乔布斯这种人除外)。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;日常开发设计中的产品思维&lt;/h3&gt;

&lt;p&gt;上面两段略显多余，跟技术好像并没有什么直接的关系，下面直接进入正文。&lt;/p&gt;

&lt;p&gt;假设我们的产品开发流程是这样的&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;需求分析 -&amp;gt; 产品设计 -&amp;gt; 开发和测试 -&amp;gt; 交付运维
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那么在这个流程中，技术人员的产品思维是&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;1、知道要做什么&lt;/h4&gt;
&lt;p&gt;技术产品的设计通常会有评审环节，因此知道要做什么不仅仅是你自己的事，还需要你的leader、组员知道。你需要说明，这个产品是什么，产品的背景是怎样的。你们之间要达成一个共同的概念，这也是沟通的前提。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;2、解决了什么问题&lt;/h4&gt;
&lt;p&gt;为什么要做，当前的技术架构存在什么痛点？对于后端丰富的产品生态，我们不需要重复造轮子，投入成本开发一款产品，我们需要知道其价值所在，其真正的产品定位，适用于什么场景，什么人。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;3、怎么做&lt;/h4&gt;
&lt;p&gt;你打算怎么做？通常我们可以先去借鉴竞对或者开源的产品，剖析他们是怎么解决当前问题的，有哪些创新点，然后结合自己的业务场景做一些微创新。这个阶段，我们需要给出详细的技术方案描述，需要有面向用户的功能视图、面向开发的流程交互视图、面向测试的接口视图以及面向运维的部署视图。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;4、什么时候做&lt;/h4&gt;
&lt;p&gt;有了完整的设计后，在你真正开始做之前，还有一个排期的问题。越晚上线的产品，对用户的吸引程度就越低，甚至有可能直接被市场淘汰。例如锤子的某款手机，从设计到上线，跨度半年以上，最初设计阶段选择的高配硬件到了上线时，已经成了低配了。产品的开发排期，可以分几个阶段，区分主次功能（前台功能为主，后台功能为次），然后进行迭代式开发。在这个阶段，对于产品将来的规划、理念甚至远景，内心里应该是清楚的。&lt;/p&gt;

&lt;h4 id=&quot;section-7&quot;&gt;5、做到什么程度&lt;/h4&gt;
&lt;p&gt;产品需要做到什么程度？如何衡量产品达到了什么程度？产品交付生产后我们需要定义并关注产品的核心指标，比如tps，qps，cpu、memory、io使用情况。如何收集这些指标？来源可以是用户反馈，也可以通过数据驱动，通过这种方式来形成产品不断改进的闭环。&lt;/p&gt;

&lt;h3 id=&quot;section-8&quot;&gt;最终我要表达的&lt;/h3&gt;
&lt;p&gt;不仅仅自己做开发设计时需要有产品思维，学习他人的产品更需要有产品思维。&lt;/p&gt;

&lt;h3 id=&quot;section-9&quot;&gt;参考链接&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;https://en.wikipedia.org/wiki/Systems_thinking&quot;&gt;Systems_thinking&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;https://www.slideshare.net/WrangleConf/the-unreasonable-effectiveness-of-product-sense&quot;&gt;The-unreasonable-effectiveness-of-product-sense&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;https://www.quora.com/What-does-it-mean-to-have-product-sense&quot;&gt;What-does-it-mean-to-have-product-sense&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://youly.github.io/2017/06/10/tech-equipment-with-product-sense</link>
                <guid>http://youly.github.io/2017/06/10/tech-equipment-with-product-sense</guid>
                <pubDate>2017-06-10T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>内容社区产品中的计数服务设计</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;引言&lt;/h3&gt;
&lt;p&gt;内容产品中比较常见的就是各种计数，比如点赞数、评论数、粉丝数等。由于近期需要实现计数的功能，因此针对如何计数实现作了下思考，并总结成本文。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;目前想到的几种实现方案&lt;/h3&gt;

&lt;h4 id=&quot;count&quot;&gt;方案一、使用数据库提供的Count函数&lt;/h4&gt;
&lt;p&gt;简单粗暴，解决问题的最快方式。比较常见的使用场景有交易系统中的订单计数，如下图，以用户为维度按状态进行分组计数，更新不是很频繁，从性能上考虑，可以在上层做缓存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/counter1.png&quot; alt=&quot;电商产品计数&quot; style=&quot;width: 220px;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然而最快并不一定意味着最好，在单用户记录数比较多的时候，利用数据库去做聚合统计成本还是相当高的，在列表场景下就更不适合了。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;方案二、独立的计数表&lt;/h4&gt;
&lt;p&gt;类似如下的表结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+----------+--------+-------------+
| biz_type | biz_id | biz_counter |
+----------+--------+-------------+
|        1 |   8094 |           3 |
|        2 |   8095 |           9 |
|        3 |   8099 |           7 |
+----------+--------+-------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过业务类型、业务id的唯一性来关联计数。业务数据的更新，同步更新db中的计数记录。同样从性能上考虑，可以在上层做一层缓存，计数更新，同步清除缓存。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/counter2.png&quot; alt=&quot;内容产品计数&quot; style=&quot;width: 220px;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;相比方案一，会减少很多db的慢查询，也适合列表式的场景，但考虑业务发展到一定规模后，尤其是内容社交型的产品，数据频繁更新，tps瞬间峰值高，导致db的开销比较大，缓存命中率也不高，故此方案也只适用于中小型产品。&lt;/p&gt;

&lt;h4 id=&quot;redis-&quot;&gt;方案三、Redis 内存存储&lt;/h4&gt;

&lt;p&gt;注意，标题是内存存储，不是内存缓存。内存存储是不设过期时间的。如果业务发展迅速，导致内存容量不够，像db扩容一样，内存也要进行扩容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/counter4.png&quot; alt=&quot;社交产品计数&quot; style=&quot;width: 220px;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虽然是内存存储，但redis是支持数据落地的，因此不必担心数据丢失。访问计数不存在，上层业务可以认为计数值就是0。这一点就避免了大部分没有计数的数据（比如无赞无评论的问题）占用不必要的内存。另外redis设计本身支持原子性的增减操作，如命令HINCRBY、INCRBY，因此也不必担心数据被改错的问题。&lt;/p&gt;

&lt;p&gt;只要保证redis的高可用，此方案相比方案一、二在性能上是最优的。然而好的东西总要付出代价，毕竟内存是昂贵的。在成本可控的情况下，要保证服务可用性，只能在软件设计上进行突破了。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;折中的方案&lt;/h3&gt;
&lt;p&gt;方案三的性能最优，但受内存成本限制，因此需要在成本与用户体验上做出一个权衡。基本思想是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用近似内存存储，设置相对较长的过期时间，挺过热数据阶段&lt;/li&gt;
  &lt;li&gt;提高内存缓存的命中率，每次缓存更新，重置过期时间&lt;/li&gt;
  &lt;li&gt;增加独立的计数表，缓存失效，从计数表中读取数据，并同步更新缓存，尽量避免使用count函数&lt;/li&gt;
  &lt;li&gt;除了以上之外，可以干脆不设置过期时间，但当redis容量达到一定阈值后，需要人工介入，把冷数据批量清除，以释放内存存储。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;基于以上思想，来看下面的计数服务架构图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/counter3.jpg&quot; alt=&quot;计数服务架构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;说明：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;计数器初始化，以select count(*) from table 的形式。项目上线前需要执行这一步&lt;/li&gt;
  &lt;li&gt;计数写入，先更新redis，然后通过队列异步更新db，保证数据落地&lt;/li&gt;
  &lt;li&gt;计数查询，优先查询redis，当redis挂掉或缓存过期，查CounterTable表，并异步初始化缓存&lt;/li&gt;
  &lt;li&gt;为保证数据正确性，上一步中的异步初始化缓存，通过步骤1中的方式进行初始化，并校验CounterTable数据正确性&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要额外注意的是，计数写入要进行判断：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;redis更新完成后，判断返回值，如果是1，则需要判断缓存是否过期，如果过期，则INCRBY/HINCRBY的结果是错误的，重新初始化缓存&lt;/li&gt;
  &lt;li&gt;或者写入之前先执行HEXISTS/EXISTS判断key是否存在，不存在则不写入，异步执行缓存初始化。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;以上都无法根本避免，在线程高并发的情况下，从取完初始化的数据到执行完HMSET期间数据丢失的可能。不过在缓存已经过期的情况下，业务上基本很少有高并发了&lt;/b&gt;&lt;/p&gt;

&lt;p&gt;欢迎有更好的方案提出来与大家共享。&lt;/p&gt;
</description>
                <link>http://youly.github.io/2017/06/06/counter-service-design-in-content-based-community</link>
                <guid>http://youly.github.io/2017/06/06/counter-service-design-in-content-based-community</guid>
                <pubDate>2017-06-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Rocketmq系列-概念</title>
                <description>&lt;h3 id=&quot;rocketmq-&quot;&gt;rocketmq 核心概念&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;Apache RocketMQ™ is an open source distributed messaging and streaming data platform.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;RocketMQ 是阿里开源的分布式消息系统，提供低延时、高可靠的消息发布与订阅服务。下图来自其官网介绍：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/rmq-model.png&quot; alt=&quot;rocketmq 模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1、message：信息的载体，rocketmq 里的消息包含 body，tag， properties。&lt;/p&gt;

&lt;p&gt;2、topic: 生产者往其中投递消息，消费者从中消费消息，生产与消费必须指定topic。&lt;/p&gt;

&lt;p&gt;3、group：一个消息的 topic 可以被多个组的生产者(producer group)生产，也可以被多个组的消费者(consumer group)消费。&lt;/p&gt;

&lt;p&gt;4、queue：topic 的内部组成，存储消息的最小单元。一个 topic 通常有一个或者多个内部 queue。&lt;/p&gt;

&lt;p&gt;5、offset：消息在 queue 里的偏移量。消费者消费消息时，broker会存储消费者的消费偏移量。&lt;/p&gt;

&lt;h3 id=&quot;rocketmq--1&quot;&gt;rocketmq 部署模型&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;物理部署结构&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/rmq-deployment-model.png&quot; alt=&quot;rocketmq 物理模型&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1、NameServer集群：提供topic的路由信息，比如生产者发布消息前，可以从 nameserver 查询消息应该被发往哪个 broker。nameserver是无状态的，集群节点之间互不通信。&lt;/p&gt;

&lt;p&gt;2、broker集群：从生产者接收消息并存储，后续消费者从这里消费消息。broker 分为 Master 与 Slave，一个 Master 可以对应多个 Slave，一个 Slave 只能对应一个 Master。broker 启动后，会定时将 topic 信息注册到所有的 nameserver。&lt;/p&gt;

&lt;p&gt;3、producer集群：生产集群，与 nameserver 中的一台建立长连接，定时拉取 topic 信息。&lt;/p&gt;

&lt;p&gt;4、consumer集群：消费集群，与 nameserver 中的一台建立长连接，定时拉取 topic 信息。&lt;/p&gt;

&lt;h3 id=&quot;rocketmq--2&quot;&gt;rocketmq 提供了哪些亮点功能？&lt;/h3&gt;

&lt;p&gt;1、消息堆积，容量依磁盘大小而定&lt;/p&gt;

&lt;p&gt;2、消息延迟发送，提供了固定的几个间隔的延迟时间设置&lt;/p&gt;

&lt;p&gt;3、消息过滤，基于tag&lt;/p&gt;

&lt;p&gt;4、消息的可靠存储&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;http://alibaba.github.io/RocketMQ-docs/document/design/RocketMQ_design.pdf&quot;&gt;RocketMQ 原理简介&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://www.jianshu.com/p/453c6e7ff81c&quot;&gt;分布式开放消息系统(RocketMQ)的原理与实践&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;https://kgyhkgyh.gitbooks.io/rocketmq/content/index.html&quot;&gt;Gitbook: RocketMQ原理详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;https://rocketmq.incubator.apache.org/docs/core-concept/&quot;&gt;RocketMQ core concept&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://youly.github.io/2017/03/17/Rocketmq-series-introduction</link>
                <guid>http://youly.github.io/2017/03/17/Rocketmq-series-introduction</guid>
                <pubDate>2017-03-17T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>java对象拷贝</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;什么是对象拷贝&lt;/h3&gt;

&lt;p&gt;对象，可以简单理解为是内存区域的一段数据。对象拷贝就是把这段数据复制到内存中的另一段区域，与原来的区别是，内存地址不同。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;为什么进行对象拷贝&lt;/h3&gt;

&lt;p&gt;由于对象其实是引用，在一个对象有很多引用的情况下，修改对象的属性，有很高的潜在风险。为了规避风险，提高程序确定性，拷贝是个很好的选择。&lt;/p&gt;

&lt;h3 id=&quot;javaclonecloneable&quot;&gt;java中的clone、cloneable&lt;/h3&gt;

&lt;h4 id=&quot;clone&quot;&gt;clone&lt;/h4&gt;

&lt;p&gt;方法签名：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected Object clone() throws CloneNotSupportedException
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;java.lang.Object类的一个实例方法，protected, 不能直接访问&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通过 field-by-field assignment 方式产生一个新的对象，不会去调用构造函数&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;返回值是一个Object对象，不能直接使用，需要进行 type cast&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果需要调用此方法，被调用类必须实现 Cloneable 接口&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于任何一个对象x，clone方法遵循如下规约：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;x.clone() != x  // always true

x.clone().getClass() == x.getClass() // true, but these are not absolute requirements

x.clone().equals(x) // be true, this is not an absolute requirement
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以下是一个利用clone实现对象拷贝的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class X implements Cloneable {
    public Object clone() {
        try {
       	    return super.clone();
    	} catch (CloneNotSupportedException e) {
       	    throw new InternalError(e.toString()); 
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;cloneable&quot;&gt;cloneable&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一个没有任何method的接口，仅用来向编译器表名，一个class是否能被拷贝&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;改变了java.lang.Object.clone()的行为，本来是protected的方法，却能以public的方式调用&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;clone-1&quot;&gt;clone方法存在的问题&lt;/h4&gt;

&lt;p&gt;clone 仅仅是 field-by-field assignment，如果 field 是一个对象引用，那么赋值到新对象的也是一个引用。如何实现对象属性也能被拷贝呢？为了区别 Object.clone 的实现方式，引入一个新的概念，&lt;font color=&quot;red&quot;&gt;&lt;em&gt;Deep clone&lt;/em&gt;&lt;/font&gt;，而 Object.clone 的实现方式叫 &lt;font color=&quot;red&quot;&gt;&lt;em&gt;Shallow clone&lt;/em&gt;&lt;/font&gt;。两者的区别如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/java-object-copy-1.jpg&quot; alt=&quot;浅拷贝&quot; /&gt;  &lt;img src=&quot;/assets/images/java-object-copy-2.jpg&quot; alt=&quot;深拷贝&quot; /&gt;&lt;/p&gt;

&lt;p&gt;以下是一个利用clone实现深拷贝的例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class X  implements Cloneable {
	private int a; // primitive
	private String b; // reference to immutable object
	private Y c; // where class Y has mutator methods

	public Object clone() { // deep clone
		try {
			X other = (X) super.clone(); // fields a &amp;amp; b OK
			other.c = (Y) c.clone(); // fix c by making a copy
			return other; // return the deep clone
		} catch (CloneNotSupportedException e) {
			throw new InternalError(e.toString());
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-2&quot;&gt;对象拷贝最佳实践&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;不要使用java.lang.Object.clone()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用拷贝构造函数&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public Y(Y y);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用静态工厂方法&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public static Y newInstance(Y y);
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;https://www.slideshare.net/fmshaon/effective-java-override-clone-method-judiciously&quot;&gt;Effective Java - Override clone() method judiciously&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://www.jusfortechies.com/java/core-java/deepcopy_and_shallowcopy.php&quot;&gt;Deep Copy And Shallow Copy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;http://javaconceptoftheday.com/clone-method-java-lang-object-class/&quot;&gt;clone() Method Of java.lang.Object Class&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://youly.github.io/2017/02/12/java-object-copy</link>
                <guid>http://youly.github.io/2017/02/12/java-object-copy</guid>
                <pubDate>2017-02-12T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>银行卡身份证编码及其验证</title>
                <description>&lt;p&gt;最近做用户身份验证，涉及到身份证、银行卡，发现这两个都有自己的编码规则，于是记录下来。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;银行卡&lt;/h3&gt;

&lt;p&gt;我们常见的银行卡由16位纯数字组成，如中国红十字会捐款账户 6215582201003818703。那么这一串数字由哪些部分组成呢？&lt;/p&gt;

&lt;p&gt;1、IIN(Issuer identifier number)&lt;/p&gt;

&lt;p&gt;前面6位表示发行者身份标识，由国际卡组织分配，其中首位是4的是VISA的卡，5是Master, 622126~622925是银联标准卡。发行者不仅仅指银行，还包含其他一些商业机构。&lt;/p&gt;

&lt;p&gt;有时IIN也被指 bank identification number (bin)。这六位中的第一位又用来唯一标识卡发行者的主要行业。以下是行业对应的编码：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;MII digit&lt;/th&gt;
      &lt;th&gt;value	Issuer category&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;ISO/TC 68 and other industry assignments&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;Airlines&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;Airlines, financial and other future industry assignments&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;Travel and entertainment&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;Banking and financial&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;Banking and financial&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;Merchandising and banking/financial&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;7&lt;/td&gt;
      &lt;td&gt;Petroleum and other future industry assignments&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;8&lt;/td&gt;
      &lt;td&gt;Healthcare, telecommunications and other future industry assignments&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;9&lt;/td&gt;
      &lt;td&gt;For assignment by national standards bodies&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;2、个人账户标识&lt;/p&gt;

&lt;p&gt;从第二位开始至倒数第二位，有发卡行自定义，每个银行的个人账号标识规则有所不同。有的银行在这部分内容中会包含分行、支行、储蓄网点等代码信息。&lt;/p&gt;

&lt;p&gt;3、校验位&lt;/p&gt;

&lt;p&gt;最后一位为银行卡校验位，用来验证前面的一串数字是否为合法的卡号。校验位是如何生成的呢？&lt;/p&gt;

&lt;h5 id=&quot;luhm-&quot;&gt;Luhm 校验算法&lt;/h5&gt;

&lt;p&gt;1，将未带校验位的 15 位卡号从右依次编号 1 到 15，位于奇数位号上的数字乘以 2, 第 16 位是校验码&lt;/p&gt;

&lt;p&gt;2，将奇位乘积的个十位全部相加，再加上所有偶数位上的数字&lt;/p&gt;

&lt;p&gt;3，将加法和加上校验位能被 10 整除。&lt;/p&gt;

&lt;p&gt;例如银行卡6215582201003818703，出去最后一位校验位3，其计算规则是基数位乘以2：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;6    2   1   5    5   8   2   2   0  1   0   0  3   8    1   8   7  0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;6    4   1   10   5  16   2   4   0  2   0   0  3   16   1   16  7  0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;结果相加：&lt;/p&gt;

&lt;p&gt;6 + (4) + 1 + (1 + 0) + 5 + (1 + 6) + 2 + (4) + 0 + (2) + 0 + (0) + 3 + (1 + 6) + 1 + (1 + 6) + 7 + (0) = 57&lt;/p&gt;

&lt;p&gt;(57 + 3) % 10 == 0&lt;/p&gt;

&lt;p&gt;php程序实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  public function bankcard_check($bankcard) {
    $bankcard = str_replace(' ', '', trim($bankcard));
    if (!$bankcard || !preg_match('/^\d{5,30}$/', $bankcard)) {
        return FALSE;
    }
    $checkcode = substr($bankcard, -1);
    $bankcard = substr($bankcard, 0, -1);
    $len = strlen($bankcard);
    $luhm_sum = 0;
    $j = 1;
    for ($i = $len - 1; $i &amp;gt;= 0; $i--)  {
        $k = intval($bankcard[$i]);
        if ($j % 2 == 1) {
            $k *= 2;
            $k = intval($k / 10) + $k % 10;
        }

        $luhm_sum += $k;
        $j++;
    }
    if (($luhm_sum + $checkcode) % 10 == 0) {
        return $bankcard . $checkcode;
    }
    return FALSE;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h5 id=&quot;section-1&quot;&gt;附&lt;/h5&gt;

&lt;p&gt;&lt;a href=&quot;/assets/files/banks.php.txt&quot;&gt;银行列表&lt;/a&gt;，不是最新的，但包含大多数银行，可参考。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;身份证&lt;/h3&gt;

&lt;p&gt;中国公民第二代身份证由18位数字字符组成，分成四个部分：&lt;/p&gt;

&lt;p&gt;1、地址码&lt;/p&gt;

&lt;p&gt;表示编码对象常住户口所在县（市、旗、区）的行政区划代码，省市区都是两位&lt;/p&gt;

&lt;p&gt;省编码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$city = array(
	11 =&amp;gt; &quot;北京&quot;,
	12 =&amp;gt; &quot;天津&quot;,
	13 =&amp;gt; &quot;河北&quot;,
	14 =&amp;gt; &quot;山西&quot;,
	15 =&amp;gt; &quot;内蒙古&quot;,
	21 =&amp;gt; &quot;辽宁&quot;,
	22 =&amp;gt; &quot;吉林&quot;,
	23 =&amp;gt; &quot;黑龙江&quot;,
	31 =&amp;gt; &quot;上海&quot;,
	32 =&amp;gt; &quot;江苏&quot;,
	33 =&amp;gt; &quot;浙江&quot;,
	34 =&amp;gt; &quot;安徽&quot;,
	35 =&amp;gt; &quot;福建&quot;,
	36 =&amp;gt; &quot;江西&quot;,
	37 =&amp;gt; &quot;山东&quot;,
	41 =&amp;gt; &quot;河南&quot;,
	42 =&amp;gt; &quot;湖北&quot;,
	43 =&amp;gt; &quot;湖南&quot;,
	44 =&amp;gt; &quot;广东&quot;,
	45 =&amp;gt; &quot;广西&quot;,
	46 =&amp;gt; &quot;海南&quot;,
	50 =&amp;gt; &quot;重庆&quot;,
	51 =&amp;gt; &quot;四川&quot;,
	52 =&amp;gt; &quot;贵州&quot;,
	53 =&amp;gt; &quot;云南&quot;,
	54 =&amp;gt; &quot;西藏&quot;,
	61 =&amp;gt; &quot;陕西&quot;,
	62 =&amp;gt; &quot;甘肃&quot;,
	63 =&amp;gt; &quot;青海&quot;,
	64 =&amp;gt; &quot;宁夏&quot;,
	65 =&amp;gt; &quot;新疆&quot;,
	71 =&amp;gt; &quot;台湾&quot;,
	81 =&amp;gt; &quot;香港&quot;,
	82 =&amp;gt; &quot;澳门&quot;,
	91 =&amp;gt; &quot;国外&quot;
);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2、出生日期码&lt;/p&gt;

&lt;p&gt;表示编码对象出生的年、月、日，年（YYYY)，月(mm), 日(dd)&lt;/p&gt;

&lt;p&gt;3、顺序码&lt;/p&gt;

&lt;p&gt;表示在同一地址码所标识的区域范围，对同年、同月、同日出生的人编定的顺序号，顺序码奇数分配给男性，偶数分配给女性。&lt;/p&gt;

&lt;p&gt;4、校验码&lt;/p&gt;

&lt;p&gt;生成规则遵循 &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_7064&quot;&gt;iso7064&lt;/a&gt; mod11-2&lt;/p&gt;

&lt;p&gt;十七位数字本体码加权求和公式：&lt;/p&gt;

&lt;p&gt;S= SUM(Ai * Wi), i=0, … , 16&lt;/p&gt;

&lt;p&gt;Ai：表示第i位置上的身份证号码数字值&lt;/p&gt;

&lt;p&gt;Wi：表示第i位置上的加权因子，值为：[7 9 10 5 8 4 2 1 6 3 7 9 10 5 8 4 2]&lt;/p&gt;

&lt;p&gt;S对11取模，得到一个校验码索引，根据索引可得到校验码的值：[1 0 X 9 8 7 6 5 4 3 2]&lt;/p&gt;

&lt;p&gt;php代码校验：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function id_number_check($number) {
	if (!preg_match('/^(\d{6})(19|20)?(\d{2})([01]\d)([0123]\d)(\d{3})(\d|x)?$/i', $number)) {
		return FALSE;
	}

	// $city 变量上面已定义
	if (empty($city[substr($number, 0, 2)])) {
		return FALSE;
	}
	// 加权因子
	$factor = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];
	// 校验位
	$parity = [1, 0, 'X', 9, 8, 7, 6, 5, 4, 3, 2];
	$sum = 0;
	$ai = 0;
	$wi = 0;
	for ($i = 0; $i &amp;lt; 17; $i++) {
		$ai = $number[$i];
		$wi = $factor[$i];
		$sum += $ai * $wi;
	}
	$last = $parity[$sum % 11];
	if ($last != $number[17]) {
		return FALSE;
	}
	return TRUE;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;https://en.wikipedia.org/wiki/ISO/IEC_7812&quot;&gt;ISO/IEC_7812&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://blog.sina.com.cn/s/blog_12fc3a84d0101u7o8.html&quot;&gt;银行卡编码规则&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;http://vdisk.weibo.com/s/tFDQbBuhBAKN?from=page_100505_profile&amp;amp;wvr=6&quot;&gt;GB 11643-1999&lt;/a&gt;&lt;/p&gt;

</description>
                <link>http://youly.github.io/2015/09/26/codings-of-cards</link>
                <guid>http://youly.github.io/2015/09/26/codings-of-cards</guid>
                <pubDate>2015-09-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用rabbitmq提供高可用性队列服务(2)</title>
                <description>&lt;p&gt;&lt;a href=&quot;/2015/05/30/rabbitmq-cluster-with-high-availability-1/&quot;&gt;上篇文章&lt;/a&gt;提到了rabbitmq的一些概念和特性，本文承接上文，讲解如何通过docker部署rabbitmq节点。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;准备环境&lt;/h3&gt;

&lt;p&gt;rabbitmq集群有几点要求：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;节点拥有相同的Erlang、Rabbitmq版本&lt;/li&gt;
  &lt;li&gt;节点拥有相同的Erlang Cookie（Erlang虚拟机使用cookie来决定节点间能否通信）&lt;/li&gt;
  &lt;li&gt;节点网络处于同一个网段&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;为了满足以上要求，本文使用docker来部署rabbitmq节点。&lt;/p&gt;

&lt;h4 id=&quot;docker&quot;&gt;安装docker&lt;/h4&gt;

&lt;p&gt;由于 docker daemon 使用到了linux内核的一些特性，因此docker的安装对于操作系统类型和版本有一些要求。&lt;/p&gt;

&lt;p&gt;对于 centos，要求版本6.5及以上，内核版本2.6.32-431及以上。可参考&lt;a href=&quot;https://docs.docker.com/installation/centos/&quot;&gt;文档说明&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;当然 Mac OS X 是不支持的。如果一定要在mac上玩，可以下载&lt;a href=&quot;https://github.com/boot2docker/osx-installer/releases&quot;&gt;boot2docker&lt;/a&gt;，为运行docker定制的虚拟机。&lt;/p&gt;

&lt;h4 id=&quot;docker-1&quot;&gt;制作docker镜像&lt;/h4&gt;

&lt;p&gt;本文将在centos下安装和运行rabbitmq，docker安装完后执行以下命令下载centos镜像：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker pull centos
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接下来制作rabbitmq镜像，以便可以启动多个容器：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 启动一个 centos 环境下运行 bash 程序的容器
docker run -it centos /bin/bash

# 安装 Erlang
yum -y install wget
mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.163.com/.help/CentOS7-Base-163.repo
yum -y update
mkdir packages &amp;amp;&amp;amp; cd packages
wget http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm
wget http://rpms.famillecollet.com/enterprise/remi-release-6.rpm
rpm -Uvh remi-release-6*.rpm epel-release-6*.rpm
yum install -y erlang

# 安装 Rabbitmq
wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.2.2/rabbitmq-server-3.2.2-1.noarch.rpm
rpm --import http://www.rabbitmq.com/rabbitmq-signing-key-public.asc
yum -y install rabbitmq-server-3.2.2-1.noarch.rpm

# 启用 rabbitmq 管理插件
rabbitmq-plugins enable rabbitmq_management

# 设置 Erlang Cookie
RUN echo &quot;ERLANGCOOKIE&quot; &amp;gt; /var/lib/rabbitmq/.erlang.cookie
RUN chown rabbitmq:rabbitmq /var/lib/rabbitmq/.erlang.cookie
RUN chmod 400 /var/lib/rabbitmq/.erlang.cookie
chown -R rabbitmq:rabbitmq /var/lib/rabbitmq

# 安装其他一些工具
yum -y install net-tools vim

yum install -y passwd openssh-clients openssh-server
ssh-keygen -f /etc/ssh/ssh_host_rsa_key
ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key
echo 'root:root' | chpasswd
/bin/sed -i 's/.*session.*required.*pam_loginuid.so.*/session optional pam_loginuid.so/g' /etc/pam.d/sshd
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上命令(可以写成一个Dockerfile)执行完后，一个rabbitmq环境就搭建好了，control + p &amp;amp;&amp;amp; control +q 退出当前容器，执行以下命令，提交 image：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# 查看当前所有容器
docker ps -a

# 选择刚才制作好的container，执行
docker commit {container id} rabbitmq

# 查看image
docker images
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;rabbitmq&quot;&gt;启动rabbitmq节点&lt;/h3&gt;

&lt;p&gt;启动主机名为rbq1的节点：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -it -h rbq1 rabbitmq /bin/bash
[root@rbq1 /]# rabbitmq-server -detached
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;启动主机名为rbq2的节点：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker run -it -h rbq2 rabbitmq /bin/bash
[root@rbq2 /]# rabbitmq-server -detached
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;修改主机rbq1、rbq2，hosts文件分别新增以下两行&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;172.17.0.4      rbq1
172.17.0.6      rbq2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;rabbitmq-1&quot;&gt;配置rabbitmq集群&lt;/h3&gt;

&lt;p&gt;我们以 rbq1 为主节点，将 rbq2 作为salve加入到rbq1集群:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@rbq2 /]# rabbitmqctl join_cluster rabbit@rbq1
[root@rbq2 /]# rabbitmqctl  start_app
Starting node rabbit@rbq2 ...
...done.
[root@rbq2 /]# rabbitmqctl cluster_status
Cluster status of node rabbit@rbq2 ...
[{nodes,[{disc,[rabbit@rbq1,rabbit@rbq2]}]},
 {running_nodes,[rabbit@rbq1,rabbit@rbq2]},
  {partitions,[]}]
  ...done.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在 rbq1 上执行：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@rbq1 /]# rabbitmqctl cluster_status
Cluster status of node rabbit@rbq1 ...
[{nodes,[{disc,[rabbit@rbq1,rabbit@rbq2]}]},
 {running_nodes,[rabbit@rbq2,rabbit@rbq1]},
  {partitions,[]}]
  ...done.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ha&quot;&gt;配置集群ha&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[root@rbq1 /]# rabbitmqctl set_policy ha-all &quot;^ha\.&quot; '{&quot;ha-mode&quot;:&quot;all&quot;}'
Setting policy &quot;ha-all&quot; for pattern &quot;^ha\\.&quot; to &quot;{\&quot;ha-mode\&quot;:\&quot;all\&quot;}&quot; with priority &quot;0&quot; ...
...done.
[root@rbq1 /]# rabbitmqctl list_policies
Listing policies ...
/   ha-all  all ^ha\\.  {&quot;ha-mode&quot;:&quot;all&quot;}   0
...done.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上指令配置了所有以ha开头的队列在所有节点中镜像一份。rabbitmq镜像模式有以下几种：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/rabbitmq-ha.png&quot; alt=&quot;rabbitmq-ha&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.rabbitmq.com/clustering.html&quot;&gt;Rabbitmq Clustering Guide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;https://www.rabbitmq.com/ha.html&quot;&gt;Rabbitmq Highly Available Queues&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;https://www.rabbitmq.com/distributed.html&quot;&gt;Distributed RabbitMQ brokers&lt;/a&gt;&lt;/p&gt;

</description>
                <link>http://youly.github.io/2015/06/06/rabbitmq-cluster-with-high-availability-2</link>
                <guid>http://youly.github.io/2015/06/06/rabbitmq-cluster-with-high-availability-2</guid>
                <pubDate>2015-06-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用rabbitmq提供高可用性队列服务(1)</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;为什么使用队列&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/queue.jpeg&quot; alt=&quot;queue&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一个复杂的业务系统，为了保证尽可能小的响应时间和高的吞吐率，必然关联到模块的解耦和业务的拆分。非核心业务异步化，保证业务的关键路径尽可能短。而解耦和异步化的一个实现方式就是消息中间件。通过消息来连接不同的业务，在扩展性，系统稳定性上提供了一个很好的解决方案。&lt;/p&gt;

&lt;h3 id=&quot;rabbitmq&quot;&gt;为什么是rabbitmq&lt;/h3&gt;

&lt;p&gt;1、支持&lt;a href=&quot;http://en.wikipedia.org/wiki/Advanced_Message_Queuing_Protocol&quot;&gt;AMQP&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、消息可靠性：发送确认、接收回执、消息落地、高可用性&lt;/p&gt;

&lt;p&gt;3、灵活的路由方式：点对点、广播，基于正则的转发&lt;/p&gt;

&lt;p&gt;4、服务集群，节点间共享用户、队列、exchange等，节点间负载能够均衡&lt;/p&gt;

&lt;p&gt;5、消息的高可用性：分布式的架构，以牺牲网络分区的代价，换来服务的高可用性和数据一致性&lt;/p&gt;

&lt;p&gt;6、提供web的管理界面&lt;/p&gt;

&lt;p&gt;7、提供多语言的客户端&lt;/p&gt;

&lt;h3 id=&quot;cap-theorem&quot;&gt;cap theorem&lt;/h3&gt;

&lt;p&gt;分布式服务架构需要参考的一个&lt;a href=&quot;http://en.wikipedia.org/wiki/CAP_theorem&quot;&gt;重要定理&lt;/a&gt;，在一个分布式的系统中，不可能同时达到以下三点：&lt;/p&gt;

&lt;p&gt;1、一致性，所有节点在同一时刻保持着同样的状态&lt;/p&gt;

&lt;p&gt;2、可用性，保证所有的请求都有一个响应&lt;/p&gt;

&lt;p&gt;3、分区容忍，即使某个分区失败，还能持续提供服务&lt;/p&gt;

&lt;p&gt;rabbitmq提供的高可用集群参考了这一理论，提供一致性的数据、高可用性的服务，但却牺牲了分区容忍。&lt;/p&gt;

&lt;p&gt;这里提到cap theorem，只是了解，并未作深入研究。&lt;/p&gt;

&lt;h3 id=&quot;rabbitmq-1&quot;&gt;rabbitmq集群&lt;/h3&gt;

&lt;p&gt;由多个rabbitmq节点组成逻辑上的一个节点，每个节点间共享用户、vhost、队列信息、exchange等。除了队列的消息（只存储在创建此队列的节点上），其他所有对数据、状态的更新在每个节点中都执行了一遍。因此，无论连接集群中的那个节点，都能得到一致的结果。通常集群的部署方式如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/rabbitmq_ha.png&quot; alt=&quot;rabbitmq_ha&quot; /&gt;&lt;/p&gt;

&lt;p&gt;实际上，rabbitmq的集群仅仅是提供了扩展性，能够在多节点间负载均衡，但消息仅仅是存储在其中一台节点，一旦这台节点挂掉，关联此队列的所有服务就不能用了。&lt;/p&gt;

&lt;p&gt;###rabbitmq集群高可用性&lt;/p&gt;

&lt;p&gt;通过设置policy，将队列消息镜像到所有节点，消息的发布与删除，都能同步到各个节点。这样，当master节点挂掉，可以从salve节点中再推举一台作为master。&lt;/p&gt;

&lt;p&gt;针对此点，在运维rabbitmq集群过程中，需要注意到以下几点：&lt;/p&gt;

&lt;p&gt;1、last shutdown, first startup&lt;/p&gt;

&lt;p&gt;2、加入一个新的节点（salve），尽量不要显示地同步队列数据，那样会中断此队列的服务，让salve自然同步&lt;/p&gt;

&lt;p&gt;3、不要将集群节点部署到跨网段里。&lt;/p&gt;

&lt;p&gt;4、重启一个salve节点，其持久保存的数据将被丢弃。&lt;/p&gt;

&lt;p&gt;5、需要移除master节点或者选择一个新的master时，要执行 rabbitmqctl forget_cluster_node，然后才启动salves。&lt;/p&gt;

&lt;h3 id=&quot;rabbitmq-2&quot;&gt;rabbitmq集群搭建&lt;/h3&gt;

&lt;p&gt;请参考&lt;a href=&quot;/2015/06/06/rabbitmq-cluster-with-high-availability-2&quot;&gt;下一篇文章&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.rabbitmq.com/clustering.html&quot;&gt;Rabbitmq Clustering Guide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://www.rabbitmq.com/ha.html&quot;&gt;Rabbitmq Highly Available Queues&lt;/a&gt;&lt;/p&gt;

</description>
                <link>http://youly.github.io/2015/05/30/rabbitmq-cluster-with-high-availability-1</link>
                <guid>http://youly.github.io/2015/05/30/rabbitmq-cluster-with-high-availability-1</guid>
                <pubDate>2015-05-30T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>synchronized与lock的区别</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;几个概念&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;共享变量(shared variable)：多个线程都能访问的变量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;变量可见性(variable visibility)：一个线程更新了共享变量，对其他线程立刻可见。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;互斥(mutual exclusion )：几个线程中的任何一个不能与其他一个或多个同时操作一个变量。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;临界区(critical section)：访问共享资源的一段代码块。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;synchronized&quot;&gt;synchronized解决的问题&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;保证共享变量的可见性：变量缓存与编译器指令优化 会导致 变量修改的不可见性。&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;The Java virtual machine (JVM) supports this mechanism via monitors and the associated monitorenter and monitorexit instructions.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;保证共享变量的互斥性：同一时刻只能有一个线程对共享变量的修改（注意修改一次，是先读再写，是两个操作）。monitor lock实现，monitor提供了一种互斥访问的机制，保证只有一个进程进入临界区。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;synchronizedlock&quot;&gt;synchronized与lock的区别&lt;/h3&gt;

&lt;p&gt;自jdk1.5后java.util.concurrent包提供了更广泛通用的锁实现lock，名字上的区别是，一个是隐式锁(intrinsic locking)，一个是显示锁(explicit lock)，从这点上来说，用户对显示锁有更多地控制。具体区别有以下几点：&lt;/p&gt;

&lt;p&gt;1）lock提供了如下的方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;void lock()，获取一个锁，如果锁当前被其他线程获得，当前的线程将被休眠。&lt;/li&gt;
  &lt;li&gt;boolean tryLock()，尝试获取一个锁，如果当前锁被其他线程持有，则返回false，不会使当前线程休眠。&lt;/li&gt;
  &lt;li&gt;boolean tryLock(long timeout,TimeUnit unit)，如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false。&lt;/li&gt;
  &lt;li&gt;void lockInterruptibly()，如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;可见lock比synchronized提供了更细的粒度、更灵活的控制。&lt;/p&gt;

&lt;p&gt;2） synchronized是在JVM层面上实现的，如果代码执行时出现异常，JVM会自动释放monitor锁。而lock代码是用户写的，需要用户来保证最终释放掉锁。通常使用lock的代码需要这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Lock l = ...; // 获取锁
l.lock();
try 
{
  // access the resource protected by this lock
} catch (Exception ex) 
{
  // restore invariants
}
finally 
{
   l.unlock();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3）lock提供了一个重要的方法newConditon()，ConditionObject有await()、signal()、signalAll()，类似于Ojbect类的wait()、notify()、notifyAll()。这些方法都是用来实现线程间通信。lock将synchronized的互斥性和线程间通信分离开来，一个lock可以有多个condition。另外lock的signal可以实现公平的通知，而notify是随机从锁等待队列中唤醒某个进程。&lt;/p&gt;

&lt;p&gt;4）性能上来说，在多线程竞争比较激烈地情况下，lock比synchronize高效得多。如何说明一个锁更高效？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A better lock implementation makes fewer system calls, forces fewer context switches, and initiates less memory-synchronization traffic on the shared memory bus, operations that are time-consuming and divert computing resources from the program.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;http://www.javaworld.com/article/2078848/java-concurrency/java-101-the-next-generation-java-concurrency-without-the-pain-part-2.html&quot;&gt;java-101-the-next-generation-java-concurrency-without-the-pain-part-2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://my.safaribooksonline.com/book/programming/java/0321349601/explicit-locks/ch13lev1sec4&quot;&gt;Choosing Between Synchronized and ReentrantLock&lt;/a&gt;&lt;/p&gt;

</description>
                <link>http://youly.github.io/2015/02/04/difference-between-java-lock-and-synchronized</link>
                <guid>http://youly.github.io/2015/02/04/difference-between-java-lock-and-synchronized</guid>
                <pubDate>2015-02-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Jetty源码阅读 - server</title>
                <description>&lt;p&gt;接着上篇&lt;a href=&quot;/2015/01/26/jetty-connector/&quot;&gt;Jetty源码阅读 - connector&lt;/a&gt;，本文将分析jetty组件中server组件的源码，基于jetty-9.3.0。&lt;/p&gt;

&lt;h3 id=&quot;server&quot;&gt;什么是Server&lt;/h3&gt;

&lt;p&gt;Jetty由若干个组件组成，Server则把这些组件关联起来，对外提供服务的接口，其在jetty整个架构中的位置如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jetty-high-level-architecture.png&quot; alt=&quot;jetty-high-level-architecture&quot; /&gt;&lt;/p&gt;

&lt;p&gt;继承自HandlerWrapper，关联connector，server在这两者之间处于一种协调关系。&lt;/p&gt;

&lt;h3 id=&quot;server-1&quot;&gt;Server类图&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jetty_server.jpg&quot; alt=&quot;jetty server&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中蓝色的线代表“类继承”，绿色实线代表“接口继承”，绿色虚线代表“接口实现”。&lt;/p&gt;

&lt;p&gt;从上图可以看到，server和handler的关系与server和connector的关系不同， server类和handler类是继承关系，而不是关联关系。&lt;/p&gt;

&lt;h3 id=&quot;server-2&quot;&gt;Server源码分析&lt;/h3&gt;

&lt;p&gt;1）server类初始化，需要四个信息，监听ip，监听port，connector组件以及线程池。如下是其中的一个构造函数（文件org.eclipse.jetty.server.Server）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Server(@Name(&quot;address&quot;)InetSocketAddress addr)
{
    this((ThreadPool)null);
    ServerConnector connector=new ServerConnector(this);
    connector.setHost(addr.getHostName());
    connector.setPort(addr.getPort());
    setConnectors(new Connector[]{connector});
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2）默认的线程池实现是org.eclipse.jetty.util.thread.QueuedThreadPool，线程池中的每个线程不断地从队列中取任务，然后执行。队列采用的是ConcurrentLinkedQueue。&lt;/p&gt;

&lt;p&gt;3）Server类继承了ContainerLifeCycle，因此它也有容器的属性，包括启动、停止等。它也管理着与容器生命周期有关的bean，如threadpool，connector。当server类start的时候，会先调用threadpool、connector的start方法。&lt;/p&gt;

&lt;p&gt;4）当connector组件接收一个连接并解析完http数据时，会将解析完后封装到HttpChannel的请求信息交给server处理。server则调用handler方法：&lt;/p&gt;

&lt;p&gt;文件org.eclipse.jetty.server.Server：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void handle(HttpChannel connection) throws IOException, ServletException
{
    final String target=connection.getRequest().getPathInfo();
    final Request request=connection.getRequest();
    final Response response=connection.getResponse();

    if (LOG.isDebugEnabled())
        LOG.debug(request.getDispatcherType()+&quot; &quot;+request.getMethod()+&quot; &quot;+target+&quot; on &quot;+connection);

    if (&quot;*&quot;.equals(target))
    {
        handleOptions(request,response);
        if (!request.isHandled())
            handle(target, request, request, response);
    }
    else
        handle(target, request, request, response);

    if (LOG.isDebugEnabled())
        LOG.debug(&quot;RESPONSE &quot;+target+&quot;  &quot;+connection.getResponse().getStatus()+&quot; handled=&quot;+request.isHandled());
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;文件org.eclipse.jetty.server.handler.HandlerWrapper：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException
{
    if (_handler!=null &amp;amp;&amp;amp; isStarted())
    {
        _handler.handle(target,baseRequest, request, response);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;1、&lt;a href=&quot;http://www.eclipse.org/jetty/documentation/current/architecture.html#basic-architecture&quot;&gt;Jetty Architecture&lt;/a&gt;&lt;/p&gt;

</description>
                <link>http://youly.github.io/2015/01/27/jetty-server</link>
                <guid>http://youly.github.io/2015/01/27/jetty-server</guid>
                <pubDate>2015-01-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Jetty源码阅读 - connector</title>
                <description>&lt;h3 id=&quot;jetty&quot;&gt;Jetty是什么&lt;/h3&gt;

&lt;p&gt;Jetty是一个开源的项目，它主要提供了一个轻量级的Web Server和Servlet容器。&lt;/p&gt;

&lt;p&gt;Jetty中有个重要的数据结构Handler，所有可以被扩展的组件都可以作为一个handler添加到server中，由jetty来管理这些handler。本文将分析jetty组件中connector组件的源码，基于jetty-9.3.0。&lt;/p&gt;

&lt;h3 id=&quot;connnector&quot;&gt;什么是connnector&lt;/h3&gt;

&lt;p&gt;Jetty由若干个组件组成，connector是其中负责处理客户端连接的组件，其在jetty整个架构中的位置如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jetty-high-level-architecture.png&quot; alt=&quot;jetty-high-level-architecture&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;connector&quot;&gt;connector类图&lt;/h3&gt;

&lt;p&gt;jetty包中主要的类 org.eclipse.jetty.server.Server 类中关联了 ServerConnector 类，ServerConnector类图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/ServerConnector.jpg&quot; alt=&quot;ServerConnector&quot; /&gt;&lt;/p&gt;

&lt;p&gt;其中蓝色的线代表“类继承”，绿色实线代表“接口继承”，绿色虚线代表“接口实现”。&lt;/p&gt;

&lt;h3 id=&quot;connector-1&quot;&gt;connector源码分析&lt;/h3&gt;

&lt;p&gt;1、成员变量ServerConnector类在Server类构造时被初始化，如下（文件org.eclipse.jetty.server.Server）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Server(@Name(&quot;port&quot;)int port)
{
    this((ThreadPool)null);

    /** 在这里初始化了connector */
    ServerConnector connector=new ServerConnector(this);
    connector.setPort(port);
    setConnectors(new Connector[]{connector});
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2、Server启动的时候会先调用各个组件bean的启动方法，然后是connector的start()方法，文件（org.eclipse.jetty.server.Server ）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
protected void doStart() throws Exception
{
    //If the Server should be stopped when the jvm exits, register
    //with the shutdown handler thread.
    if (getStopAtShutdown())
        ShutdownThread.register(this);

    //Register the Server with the handler thread for receiving
    //remote stop commands
    ShutdownMonitor.register(this);
    
    //Start a thread waiting to receive &quot;stop&quot; commands.
    ShutdownMonitor.getInstance().start(); // initialize

    //中间代码省去

    try
    {
        super.doStart(); //由父类调用各个组件bean的启动方法
    }
    catch(Throwable e)
    {
        mex.add(e);
    }
    // start connectors last
    for (Connector connector : _connectors)
    {
        try
        {   
            connector.start(); //注意这里
        }
        catch(Throwable e)
        {
            mex.add(e);
        }
    }
    
    if (isDumpAfterStart())
        dumpStdErr();

    mex.ifExceptionThrow();

    LOG.info(String.format(&quot;Started @%dms&quot;,Uptime.getUptime()));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3、ServerConnector的start方法干了些什么呢？&lt;/p&gt;

&lt;p&gt;1）打开并绑定一个ServerSocketChannel（文件org.eclipse.jetty.server.ServerConnector）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public void open() throws IOException
{
    if (_acceptChannel == null)
    {
        //中间代码省略
        if (serverChannel == null)
        {
            serverChannel = ServerSocketChannel.open();

            InetSocketAddress bindAddress = getHost() == null ? new InetSocketAddress(getPort()) : new InetSocketAddress(getHost(), getPort());
            serverChannel.socket().setReuseAddress(getReuseAddress());
            serverChannel.socket().bind(bindAddress, getAcceptQueueSize());

            _localPort = serverChannel.socket().getLocalPort();
            if (_localPort &amp;lt;= 0)
                throw new IOException(&quot;Server channel not bound&quot;);

            addBean(serverChannel);
        }

        /**
         *  注意此处是阻塞模式
         *  调用serverChannel.accept时将阻塞直到从操作系统获取到连接
         */
        serverChannel.configureBlocking(true);
        addBean(serverChannel);

        _acceptChannel = serverChannel;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2）多个线程（Acceptor）在同一个ServerSocketChannel上accept连接（文件org.eclipse.jetty.server.AbstractConnector）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    for (int i = 0; i &amp;lt; _acceptors.length; i++)
    {
        Acceptor a = new Acceptor(i);
        addBean(a);
        getExecutor().execute(a);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Acceptor类run方法最终调用到serverChannel.accept()方法，从操作系统获取到客户端的一个连接，之后将此连接交给Selector管理（文件org.eclipse.jetty.server.AbstractConnector）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        try
        {
            while (isAccepting()) //此处进入一个循环，不停地从操作系统获取已经建立的连接
            {
                try
                {
                    accept(_id); //调用serverChannel.accept()获取就绪的连接，阻塞
                }
                catch (Throwable e)
                {
                    if (isAccepting())
                        LOG.warn(e);
                    else
                        LOG.ignore(e);
                }
            }
        }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;accept方法代码如下（文件org.eclipse.jetty.server.ServerConnector）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public void accept(int acceptorID) throws IOException
{
    ServerSocketChannel serverChannel = _acceptChannel;
    if (serverChannel != null &amp;amp;&amp;amp; serverChannel.isOpen())
    {
        SocketChannel channel = serverChannel.accept();
        accepted(channel);
    }
}

private void accepted(SocketChannel channel) throws IOException
{
    channel.configureBlocking(false);
    Socket socket = channel.socket();
    configure(socket);
    _manager.accept(channel);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;3）连接交由Selector管理。上面的成员变量_manager在ServerConnector构造时被初始化。SelectorManager管理多个Selector（org.eclipse.jetty.io.                                                                                                                                               ManagedSelector），每次从channel里accept到一个连接时，_manager从selector数组中选取一个ManagedSelector，由此ManagedSelector负责此连接后续数据的读写。&lt;/p&gt;

&lt;p&gt;文件org.eclipse.jetty.io.SelectorManager，选择selector，代码接上面的_manager.accept(channel)：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void accept(SocketChannel channel)
{
    accept(channel, null);
}

public void accept(SocketChannel channel, Object attachment)
{
    final ManagedSelector selector = chooseSelector(channel);
    selector.submit(selector.new Accept(channel, attachment)); //这里异步给selector提交一个channel注册请求，将连接的数据读写交给selector统一监听
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;查看Accept类的run方法，核心代码如下（文件org.eclipse.jetty.io.ManagedSelector）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;try
{
    SelectionKey key = channel.register(_selector, 0, attachment);
    EndPoint endpoint = createEndPoint(channel, key);
    key.attach(endpoint);
}
catch (Throwable x)
{
    closeNoExceptions(channel);
    LOG.debug(x);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到这里channel向_selector注册了感兴趣的事件0，为什么是0呢？这个还不知道。除了事件，channel还附加了一个attachment，这个attachment很关键。当select系统调用返回时，数据处理的工作就由attachment来处理了，即http请求的解析，处理，响应。看看createEndPoint干了些什么（文件org.eclipse.jetty.io.ManagedSelector）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private EndPoint createEndPoint(SocketChannel channel, SelectionKey selectionKey) throws IOException
{
    EndPoint endPoint = _selectorManager.newEndPoint(channel, this, selectionKey);
    //新建endpoint时，新建并调度了一个线程，监控连接的空闲时间
    _selectorManager.endPointOpened(endPoint);
    Connection connection = _selectorManager.newConnection(channel, endPoint, selectionKey.attachment());
    endPoint.setConnection(connection);
    //新建connection时，注册了数据可读时的回调函数
    _selectorManager.connectionOpened(connection);
    if (LOG.isDebugEnabled())
        LOG.debug(&quot;Created {}&quot;, endPoint);
    return endPoint;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当connection的数据可读时，代码将走到下面，文件org.eclipse.jetty.server.HttpConnection：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public void onOpen()
{
    super.onOpen();
    fillInterested();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;文件org.eclipse.jetty.io.AbstractConnection：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void fillInterested()
{
    if (LOG.isDebugEnabled())
        LOG.debug(&quot;fillInterested {}&quot;,this);
    getEndPoint().fillInterested(_readCallback);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;HttpConnection最终调用HttpChannel的handle方法，处理此次连接:&lt;/p&gt;

&lt;p&gt;文件org.eclipse.jetty.server.HttpConnection：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public void onFillable()
{
    //后面的代码省略
    try
    {
                //后面的代码省略
        while (true)
        {
                //后面的代码省略
                boolean suspended = !_channel.handle();
                //后面的代码省略
                
        }
            
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;文件org.eclipse.jetty.server.HttpChannel：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean handle()
{
    if (LOG.isDebugEnabled())
        LOG.debug(&quot;{} handle {} &quot;, this,_request.getHttpURI());

    HttpChannelState.Action action = _state.handling();
    try
    {
        // Loop here to handle async request redispatches.
        // The loop is controlled by the call to async.unhandle in the
        // finally block below.  Unhandle will return false only if an async dispatch has
        // already happened when unhandle is called.
        loop: while (action.ordinal()&amp;lt;HttpChannelState.Action.WAIT.ordinal() &amp;amp;&amp;amp; getServer().isRunning())
        {
            boolean error=false;
            try
            {
                if (LOG.isDebugEnabled())
                    LOG.debug(&quot;{} action {}&quot;,this,action);

                switch(action)
                {
                    case REQUEST_DISPATCH:
                        if (!_request.hasMetaData())
                            throw new IllegalStateException();
                        _request.setHandled(false);
                        _response.getHttpOutput().reopen();
                        _request.setDispatcherType(DispatcherType.REQUEST);

                        List&amp;lt;HttpConfiguration.Customizer&amp;gt; customizers = _configuration.getCustomizers();
                        if (!customizers.isEmpty())
                        {
                            for (HttpConfiguration.Customizer customizer : customizers)
                                customizer.customize(getConnector(), _configuration, _request);
                        }
                        getServer().handle(this); //交给server处理
                        break;

//后面的代码省略
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;4）ServerConnector的doStart方法执行时，_manager（org.eclipse.jetty.io.SelectorManager）的doStart方法也将被执行：如下（文件org.eclipse.jetty.io.ManagedSelector）：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
protected void doStart() throws Exception
{
    super.doStart();
    for (int i = 0; i &amp;lt; _selectors.length; i++)
    {
        ManagedSelector selector = newSelector(i);
        _selectors[i] = selector;
        selector.start();
        execute(selector);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;_manager主要是调度selector任务。selector内部也有一个调度队列，负责异步处理数据读写请求。&lt;/p&gt;

&lt;p&gt;5）ManagedSelector类。ManagedSelector的run方法，其主要工作是阻塞等待监听的channel数据读写ready，以及接受新的channel数据监听请求。&lt;/p&gt;

&lt;p&gt;如果selector已经处于select状态下，需要先调用selector的wakeup方法，然后才能往selector新注册channel。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;jetty基于nio处理连接的过程总结为如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/jetty_nio.png&quot; alt=&quot;jetty nio&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;http://www.eclipse.org/jetty/documentation/current/architecture.html#basic-architecture&quot;&gt;Jetty Architecture&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://www.ibm.com/developerworks/cn/java/j-lo-jetty/&quot;&gt;Jetty 的工作原理以及与 Tomcat 的比较&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://youly.github.io/2015/01/26/jetty-connector</link>
                <guid>http://youly.github.io/2015/01/26/jetty-connector</guid>
                <pubDate>2015-01-26T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Java内存管理</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;什么是内存管理&lt;/h3&gt;

&lt;p&gt;内存管理包括内存的分配和回收。&lt;/p&gt;

&lt;p&gt;在C++语言中内存管理是由程序员显式地来完成的，这通常导致一些常见的bug，如悬空指针引用和垃圾对象导致的内存泄露。java语言自从java 2开始就提供了自动内存管理的功能：垃圾回收器。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;运行时内存组成&lt;/h3&gt;

&lt;p&gt;大致布局如下图（&lt;a href=&quot;http://www.pointsoftware.ch/de/under-the-hood-runtime-data-areas-javas-memory-model/&quot;&gt;来自&lt;/a&gt;）：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/java_memory_layout.png&quot; alt=&quot;类存布局&quot; /&gt;&lt;/p&gt;

&lt;p&gt;堆内存：所有线程共享，存储 new Objects，&lt;em&gt;对象信息&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;非堆内存，除了堆以外的内存，包括：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;方法区：和堆一样，所有线程共享，存储加载的 &lt;em&gt;类&lt;/em&gt; 描述信息（版本、字段、方法、接口等）、常量池、静态变量、即时编译的代码等数据。&lt;/li&gt;
  &lt;li&gt;虚拟机栈：线程私有，存储局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表存放了编译期可知的各种基本数据类型（ boolean、 byte、 char、 short、 int、 float、 long、 double）、 对象引用。&lt;/li&gt;
  &lt;li&gt;本地方法栈：本地方法栈则为虚拟机使用到的Native方法服务。&lt;/li&gt;
  &lt;li&gt;程序计数器：线程私有，记录每个线程当前执行字节码指令地址。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;具体布局如下图：
&lt;img src=&quot;/assets/images/java_memory_layout_2.png&quot; alt=&quot;类存布局&quot; /&gt;&lt;/p&gt;

&lt;p&gt;###堆内存管理
从垃圾的回收的角度来看，堆内存可以分为两个区域：&lt;/p&gt;

&lt;p&gt;新生代：eden + from supvivor space&lt;/p&gt;

&lt;p&gt;年老代：新生代中经过几次垃圾回收仍存活的对象 + eden中存放不下的大对象。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;垃圾回收器应该满足的特性&lt;/h3&gt;
&lt;p&gt;1、正确性：有效数据保证永远不会被错误回收，垃圾数据不应该经过几轮垃圾回收后仍保留。&lt;/p&gt;

&lt;p&gt;2、高效性：在保证应用程序不中断的情况下快速的回收垃圾。时间、空间、频次上达到一个平衡。&lt;/p&gt;

&lt;p&gt;3、紧凑性：垃圾回收后不会产生过多的分片。&lt;/p&gt;

&lt;p&gt;4、可扩展性：垃圾回收器不应该成为一个多核多线程应用程序中得一个性能瓶颈。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;分代回收&lt;/h3&gt;
&lt;p&gt;新生代：内存小，收集频繁，要求时间利用率高&lt;/p&gt;

&lt;p&gt;老年代：内存大，频次低，要求空间利用率高&lt;/p&gt;

&lt;h3 id=&quot;jvm&quot;&gt;JVM启动参数设置&lt;/h3&gt;

&lt;p&gt;-Xms，-Xmx：jvm初始化内存大小和最大内存大小，等于 年轻代大小 + 年老代大小 + 永久代大小 + 栈大小&lt;/p&gt;

&lt;p&gt;-Xmn，-XX:NewSize：堆内存中年轻代内存大小。&lt;/p&gt;

&lt;p&gt;-XX:MaxNewSize：堆内存中年轻代内存最大值。&lt;/p&gt;

&lt;p&gt;-XX:MaxPermSize：永久代内存最大值。&lt;/p&gt;

&lt;p&gt;-Xss：每个线程的堆栈大小。相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。&lt;/p&gt;

&lt;p&gt;-XX:NewRatio：Ratio of old/new generation sizes. The default value is 2.&lt;/p&gt;

&lt;p&gt;XX:SurvivorRatio：Ratio of eden/survivor space size. The default value is 8.&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf&quot;&gt;Memory Management in the Java HotSpot™ Virtual Machine&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html&quot;&gt;The Structure of the Java Virtual Machine&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;http://docs.oracle.com/cd/E22289_01/html/821-1274/configuring-the-default-jvm-and-java-arguments.html&quot;&gt;Configuring the Default JVM and Java Arguments&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4、&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html&quot;&gt;Java HotSpot VM Options&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://youly.github.io/2015/01/16/java-memory-management</link>
                <guid>http://youly.github.io/2015/01/16/java-memory-management</guid>
                <pubDate>2015-01-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>数据结构：B-tree</title>
                <description>&lt;h3 id=&quot;b-tree&quot;&gt;B-tree简介&lt;/h3&gt;
&lt;p&gt;B-tree是一种树形的数据结构，类似于&lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_tree&quot;&gt;二叉搜索树&lt;/a&gt;，但每个节点可以有多于2个的子节点。因此，二叉搜索树的性质B-tree也都有，但B-tree在磁盘数据访问上有更多地优势。我们知道，CPU访问内存的速度远比磁盘快，然而内存的容量有限，很多时候要操作的数据在内存中无法一次性全部装载，因此需要辅助存储器，然而使用辅助存储器导致的问题是寻找数据的时间远超过处理数据的时间。那么如何在辅助存储器中快速定位需要的数据？B-tree正是为这种需求而设计，它由Rudolf Bayer and Ed McCreight 于1971年发明，(B-tree中的“B”字具体指什么已经没有记载了)，可以以树的高度(磁盘seek)和内部节点key的个数(磁盘rotate)作为调整参数来缩短定位时间。&lt;/p&gt;

&lt;h3 id=&quot;b-tree-1&quot;&gt;B-tree定义&lt;/h3&gt;
&lt;p&gt;什么样的树是B-tree？定义一个节点[key，data]，key记录键值，不同的记录key值必须不同，data记录除key以外的数据，d为预先设定的任意一个大于1的正整数，定义为树的度(指向子节点的指针数量)，h为数的高度，那么B-tree应该满足如下的约束条件：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;节点中的key按照非递减的顺序排好序。&lt;/li&gt;
  &lt;li&gt;key和指针互相间隔，节点两端是指针，每个指针要么为null，要么指向另外一个节点。&lt;/li&gt;
  &lt;li&gt;所有叶节点具有相同的深度，等于树的高度。&lt;/li&gt;
  &lt;li&gt;如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于v(key1)，其中v(key1)为node的第一个key的值。&lt;/li&gt;
  &lt;li&gt;如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于v(keym)，其中v(keym)为node的最后一个key的值。&lt;/li&gt;
  &lt;li&gt;如果某个指针在节点node的左右相邻key分别是keyi和keyi+1且不为null，则其指向节点的所有key小于v(keyi+1)且大于v(keyi)。&lt;/li&gt;
  &lt;li&gt;非叶子节点key的数量n-1，指针数量为n，那么n与树的度d满足约束：d&amp;lt;=n&amp;lt;=2d。&lt;/li&gt;
  &lt;li&gt;叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下图为一个符合要求的B-tree，它的度为2：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/b-tree.png&quot; alt=&quot;b-tree&quot; /&gt;&lt;/p&gt;

&lt;p&gt;树的度大小取决于磁盘块的大小。&lt;/p&gt;

&lt;h3 id=&quot;b-tree-2&quot;&gt;B-tree算法&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;查找&lt;/h4&gt;
&lt;p&gt;从根节点开始，递归向下搜索：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果是非叶子节点，若节点key中包含所查找的数值，则返回此节点，否则遍历该节点所有的key，找到 第一个 key比所查找数值大的key 前面那个key，递归查找此key的孩子节点。&lt;/li&gt;
  &lt;li&gt;如果是叶子节点，没有找到所查找数值，返回NULL。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-1&quot;&gt;插入&lt;/h4&gt;
&lt;p&gt;插入操作在叶节点进行，找到要插入的那个叶节点，进行如下操作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;如果此节点包含key的个数n与树的度数d满足n&amp;lt;2d，则直接在此节点中插入新元素&lt;/li&gt;
  &lt;li&gt;否则，此节点包含key的个数已经“满了”，对该节点进行如下操作：
    &lt;ul&gt;
      &lt;li&gt;1、选取改节点的中间元素（包含新插入元素）。&lt;/li&gt;
      &lt;li&gt;2、新建两个节点，key小于中间元素的插入左节点，key大于中间元素的插入右节点。&lt;/li&gt;
      &lt;li&gt;3、中间元素插入父节点，若父节点又满了，重复步骤2。若父节点已是根节点，则创建一个新的根节点。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;section-2&quot;&gt;删除&lt;/h4&gt;
&lt;p&gt;删除的节点key有两种情况，内部节点key和叶子节点key。分成两个部分，删除和调整&lt;/p&gt;

&lt;p&gt;删除：&lt;/p&gt;

&lt;p&gt;若是叶子节点key：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;直接删除&lt;/li&gt;
  &lt;li&gt;若删除之后此叶子节点key数量小于d，则调整此叶子节点以满足B-tree约束。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;若是内部节点key：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从叶子节点中查找一个此节点的替代，通常是此节点左孩子中最有的叶子节点，或者右孩子中最左的叶子节点。&lt;/li&gt;
  &lt;li&gt;找到之后替换此内部节点key，并删除叶子节点中这个key。&lt;/li&gt;
  &lt;li&gt;从叶子节点中删除掉此替换的key之后，若子节点key数量小于d，则调整此叶子节点以满足B-tree约束。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;调整，假设删除key后的叶子节点为坏节点，则进行如下之一操作：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;1、若坏节点有左兄弟节点且左兄弟节点key数量大于d，则把左兄弟节点最右边的key替换掉父节点key，并把父节点key插入坏节点。&lt;/li&gt;
  &lt;li&gt;2、否则若坏节点有右兄弟且右兄弟节点key数量大于d，则把右兄弟节点最左边的key替换掉父节点key，并把父节点key插入坏节点。&lt;/li&gt;
  &lt;li&gt;否则删除父节点key并把此key加入到左孩子节点，然后将右孩子节点合并至左孩子，删除右孩子节点。若删除父节点后，若父节点key数量小于d，则重复1、2、3&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;1、D Comer, Ubiquitous B-tree; ACM Computing Surveys (CSUR), 1979&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://en.wikipedia.org/wiki/B-tree&quot;&gt;B-tree&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;http://blog.codinglabs.org/articles/theory-of-mysql-index.html&quot;&gt;MySQL索引背后的数据结构及算法原理&lt;/a&gt;&lt;/p&gt;

</description>
                <link>http://youly.github.io/2015/01/05/b-tree</link>
                <guid>http://youly.github.io/2015/01/05/b-tree</guid>
                <pubDate>2015-01-05T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Resume</title>
                <description>&lt;h1 id=&quot;section&quot;&gt;个人信息&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;刘魏威/男/1990&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;2013年毕业/本科/兰州大学计算机科学与技术系&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;工作年限：4年&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;博客：&lt;a href=&quot;http://blog.lastww.com/&quot;&gt;http://blog.lastww.com/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section-1&quot;&gt;联系方式&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;手机：13141097831&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Email：13141097831@163.com&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section-2&quot;&gt;主要技能&lt;/h1&gt;

&lt;p&gt;1、熟练掌握java技术，熟悉基于 spring + mybatis + dubbo 的应用开发。&lt;/p&gt;

&lt;p&gt;2、熟练掌握rabbitmq/rocketmq/beanstalk消息中间件的使用、redis/memcached缓存使用、mysql表结构设计及索引优化。&lt;/p&gt;

&lt;p&gt;3、熟练使用linux、vim、intellij、git、tcpdump、awk等开发调试工具。&lt;/p&gt;

&lt;p&gt;4、熟悉php、ruby、shell脚本语言。&lt;/p&gt;

&lt;p&gt;5、熟悉nginx、jetty、tomcat等web服务器。&lt;/p&gt;

&lt;p&gt;6、小型团队管理。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section-3&quot;&gt;工作经历&lt;/h1&gt;

&lt;p&gt;##1、贝贝网 &lt;code class=&quot;highlighter-rouge&quot;&gt;资深后台开发工程师&lt;/code&gt; (2015年3月 ~ 至今)&lt;/p&gt;

&lt;p&gt;###参与项目&lt;/p&gt;

&lt;p&gt;####1)交易库表拆分项目
为提升交易系统容量，满足业务快速发展的需求，先后进行了交易核心库表的垂直拆分、水平拆分，结果交易每秒创建数从最初的80提升至现在的1000。&lt;/p&gt;

&lt;p&gt;####2)交易平台1.0项目
作为交易链路负责人，打造基础业务中台，提高人效，提升核心业务系统稳定性。把交易主流程(添加购物车、购物车列表、交易确认、交易创建、交易支付)组件化，借鉴spring aop设计思想，主流程仅负责通用基础业务逻辑并提供扩展点，各业务以组件的方式监听主流程扩展点并实现其个性化逻辑。&lt;/p&gt;

&lt;p&gt;####3)交易服务化项目
为适应公司垂直业务的发展，减少基础业务重复开发成本，我们把交易系统从php平迁到了java，基础业务逻辑下层，提供更加稳定的服务化接口。项目使用dubbo框架，基于spring + mybatis构建，使用rocketmq消息中间件进行业务异步解耦，历时3个月，最终零故障切换上线。&lt;/p&gt;

&lt;p&gt;####4)商家结算系统
商家货款结算系统，从最初的按商家佣金比例发展到按商品类目佣金比例结算、从商家固定日期结算到T+N结算，系统每日结算资金在千万级，资金结算准确无误、系统运行稳定。&lt;/p&gt;

&lt;p&gt;####5)贝贝统一支付体系
统一了第三方支付渠道支付信息获取、支付回调处理逻辑，简化了第三方支付接入流程，实现了支付方式动态可配置，故障切换功能。&lt;/p&gt;

&lt;p&gt;##2、荷花亲子创业团队 &lt;code class=&quot;highlighter-rouge&quot;&gt;后端开发工程师&lt;/code&gt; （ 2014年8月 ~ 2015年2月 ）&lt;/p&gt;

&lt;p&gt;###参与项目&lt;/p&gt;

&lt;p&gt;####1）订单系统&lt;/p&gt;

&lt;p&gt;与同事创业的项目，负责订单系统设计及编码，包括加入购物车、下单、支付、物流、退款、评价等。系统使用Java实现，采用spring+mybatis+zookeeper框架，web服务器使用nginx，利用其反向代理功能实现流量分发,负责部分运维工作，代码自动化部署、服务器监控等。通过这个项目，对于数据库结构设计的合理性和拓展性、服务可用性、代码质量有了深刻的理解。&lt;/p&gt;

&lt;p&gt;####2） 商品、攻略系统&lt;/p&gt;

&lt;p&gt;商品数据结构设计：商品详情、商品SKU、商品类别及属性等。&lt;/p&gt;

&lt;p&gt;用户购买攻略数据结构设计：攻略文章发布、编辑、用户反馈等。&lt;/p&gt;

&lt;p&gt;##3、美团网 &lt;code class=&quot;highlighter-rouge&quot;&gt;后端开发工程师&lt;/code&gt;（ 2012年12月 ~ 2014年7月 ）&lt;/p&gt;

&lt;p&gt;###参与项目&lt;/p&gt;

&lt;p&gt;####1）商家账户流水系统&lt;/p&gt;

&lt;p&gt;对美团网的每一笔资金进出准确地记录，负责系统设计及编码，每日处理上千万笔资金流水。采用复式记账法，业务动作(用户支付、美团券验证等)的发生促发一笔资金的流动。系统使用php实现，在具体业务代码、框架回调层植入流水记录代码，数据临时存储至beanstalk队列，后由supervise守护的多个php进程来异步消费队列数据，将最终计算得到的数据存入mysql（按天分表）。此系统在稳定性，数据一致性、准确性上有良好的保证。&lt;/p&gt;

&lt;p&gt;####2）用户退款提现&lt;/p&gt;

&lt;p&gt;负责用户退款申请及提现至原支付方，采用crontab定时任务的方式处理退款审核、付款至原支付方。使用工厂模式封装了支付宝、财付通、微信、银联等第三方的退款接口，系统每日处理上万笔退款，支持网络失败重试（保证不多付）。&lt;/p&gt;

&lt;p&gt;####3）对账平台开发&lt;/p&gt;

&lt;p&gt;主要处理美团业务账单与第三方支付平台账单的对账，实现外部账单下载、解析、入库，按天对账，及时发现不平账单并报警。&lt;/p&gt;

&lt;p&gt;####4）商品单业务&lt;/p&gt;

&lt;p&gt;负责商品购物单的售后服务（用户端退货、退款申请）设计及编码、商品物流信息推送及展示、商家后台商品报名、订单下载、发货信息上传、发货率统计等。&lt;/p&gt;

&lt;p&gt;####5）后台信息管理系统&lt;/p&gt;

&lt;p&gt;刚入职时作为新人参与后台系统需求的开发与维护、性能监控与优化。&lt;/p&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;section-4&quot;&gt;业余爱好&lt;/h1&gt;

&lt;p&gt;1、阅读、电影、LOL、网易公开课&lt;/p&gt;

&lt;p&gt;2、略懂摄影，不过比较宅~&lt;/p&gt;

&lt;p&gt;3、自驾游，徒步。&lt;/p&gt;
</description>
                <link>http://youly.github.io/2014/12/18/resume</link>
                <guid>http://youly.github.io/2014/12/18/resume</guid>
                <pubDate>2014-12-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>Java类加载器-ClassLoader</title>
                <description>&lt;h3 id=&quot;classloader&quot;&gt;什么是ClassLoader&lt;/h3&gt;
&lt;p&gt;简单地将，ClassLoader是类加载器，运行时动态加载类定义。给定一个类名，ClassLoader尝试获取或者生成此类的定义。最常见的是从文件系统读取编译完成的class文件来加载类。&lt;/p&gt;

&lt;h3 id=&quot;classloader-1&quot;&gt;什么时候需要ClassLoader&lt;/h3&gt;
&lt;p&gt;1、使用new方法或者Class.forName创建类的实例&lt;/p&gt;

&lt;p&gt;2、使用类或接口的静态变量，而此类当前仍未加载&lt;/p&gt;

&lt;p&gt;3、使用类的静态方法，而此类当前仍未加载&lt;/p&gt;

&lt;p&gt;4、初始化一个类的子类&lt;/p&gt;

&lt;p&gt;5、Java虚拟机启动时运行启动类main方法（Main Class）&lt;/p&gt;

&lt;h3 id=&quot;classloader-2&quot;&gt;ClassLoader遵循的原则&lt;/h3&gt;
&lt;p&gt;1、ClassLoader以层次结构组织，除了根类加载器(bootstrap class loader)，每个classloader必须要有一个“父”classloader。虽然是层级关系，但不是实际上的继承关系，这么做主要是解决安全问题，把类以命名空间隔离开来。&lt;/p&gt;

&lt;p&gt;示例图，来自&lt;a href=&quot;http://javaeesupportpatterns.blogspot.com/2012/08/javalangnoclassdeffounderror-parent.html&quot;&gt;这里&lt;/a&gt;：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/JVM_classloader_delagation_model_parent_first.png&quot; alt=&quot;jvm_classloader&quot; /&gt;&lt;/p&gt;

&lt;p&gt;2、加载一个类时，类加载器应该先委托它的父类加载器来加载，层层委托，如果上层classloader都无法加载，则由自己来加载，自己无法加载，抛ClassNotFoundException。&lt;/p&gt;

&lt;p&gt;3、一个class由类的名称和它的类加载器定义。&lt;/p&gt;

&lt;p&gt;4、一个class仅被加载一次，加载之后字节码被缓存于它的classloader中。&lt;/p&gt;

&lt;p&gt;5、class中的符号链接在此链接指向的类真正被使用时由jvm决定使用哪个classloader来加载，即这个classloader当前是不确定的。&lt;/p&gt;

&lt;p&gt;6、类型转换时，如果源类和目标类对应的classloader不同，转换将失败。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;类文件结构&lt;/h3&gt;
&lt;p&gt;ClassLoader如何加载类，还需了解下类文件结构。&lt;/p&gt;

&lt;p&gt;请参考这里：&lt;a href=&quot;http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html&quot;&gt;http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ClassFile {
    u4             magic;
    u2             minor_version;
    u2             major_version;
    u2             constant_pool_count;
    cp_info        constant_pool[constant_pool_count-1];
    u2             access_flags;
    u2             this_class;
    u2             super_class;
    u2             interfaces_count;
    u2             interfaces[interfaces_count];
    u2             fields_count;
    field_info     fields[fields_count];
    u2             methods_count;
    method_info    methods[methods_count];
    u2             attributes_count;
    attribute_info attributes[attributes_count];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;jdk-classloader&quot;&gt;JDK ClassLoader&lt;/h3&gt;
&lt;p&gt;jdk自带三种的类加载器：&lt;/p&gt;

&lt;p&gt;1、BootStrap ClassLoader：启动类加载器，这个所有类加载的根，负责加载JDK中的核心类库，类路径为sun.boot.class.path指定&lt;/p&gt;

&lt;p&gt;2、Extension ClassLoader：扩展类加载器，加载jdk中得扩展类库，路径为JAVA_HOME/jre/lib/ext&lt;/p&gt;

&lt;p&gt;3、App ClassLoader：应用程序类加载器，负责加载应用程序classpath目录下的所有jar和class文件&lt;/p&gt;

&lt;p&gt;这三种类加载器的关系如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/classloader_hierarchy.gif&quot; alt=&quot;classloader_hierarchy&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;classloader-3&quot;&gt;自定义ClassLoader&lt;/h3&gt;
&lt;p&gt;为什么要自定义classloader呢？&lt;/p&gt;

&lt;p&gt;有的时候需要隔离包之间的访问权限，比如一个系统使用java编写，它依赖一些外部包，而不想使用此系统的应用程序类感觉到这些外部包的存在，此系统可以实现自己的classloader。&lt;/p&gt;

&lt;p&gt;还有些时候，我们会动态生成一些类，也需要用到自定义classloader。&lt;/p&gt;

&lt;p&gt;实现自定义classloader很简单，jdk提供了一个抽象类ClassLoader，只需要重写它的findClass方法。&lt;/p&gt;

&lt;p&gt;示例代码可点击&lt;a href=&quot;https://github.com/youly/study/blob/master/src/main/java/com/lastww/study/basis/MyClassLoader.java&quot;&gt;此处&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/ClassLoader.html&quot;&gt;ClassLoader&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://www.oracle.com/technetwork/articles/javase/classloaders-140370.html&quot;&gt;Understanding Network Class Loaders&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;http://www.itzhai.com/java-virtual-machine-notes-jvm-class-loading-connection-and-manually-load-the-class-initialization.html&quot;&gt;JVM 类的加载、连接和初始化 手动加载类&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4、&lt;a href=&quot;http://www.onjava.com/pub/a/onjava/2003/11/12/classloader.html&quot;&gt;Inside Class Loaders&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://youly.github.io/2014/12/16/java-classloader</link>
                <guid>http://youly.github.io/2014/12/16/java-classloader</guid>
                <pubDate>2014-12-16T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用spring声明式事务</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;为什么使用事务&lt;/h3&gt;
&lt;p&gt;事务有四个特性：&lt;/p&gt;

&lt;p&gt;1、原子性：事务作为一个整理执行，包含在其中的数据库操作要么全部执行，要么不执行。&lt;/p&gt;

&lt;p&gt;2、一致性：修改数据必须满足约束，包含完整性约束、级联回滚、触发器。&lt;a href=&quot;http://en.wikipedia.org/wiki/Consistency_(database_systems)&quot;&gt;wiki传送&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、隔离性：确定了事务并发时对其他用户和系统的可见性。一般数据库提供了四个隔离级别：串行、不可重复读、读提交、脏读。&lt;/p&gt;

&lt;p&gt;4、持久性：事务提交后，被操作数据被永久保存下载，而不是存在内存中。&lt;/p&gt;

&lt;p&gt;在交易系统中，所有数据库操作必须要保证原子性、持久性，因此使用事务。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;什么是声明式事务&lt;/h3&gt;
&lt;p&gt;声明式事务是spring提供事务管理的一种方式，即通过配置来声明事务管理。spring的声明式事务通过AOP + 代理实现。spring提供的另外一种事务管理是编程式事务。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;与编程式事务相比&lt;/h3&gt;
&lt;p&gt;声明式事务无需编写额外的事务初始化、提交、回滚代码，无需小心翼翼捕获各种异常进而回滚操作，优点是很明显的。但也有缺点，需懂点配置，代码中有异常要转换成运行时异常抛出让上层知道。&lt;/p&gt;

&lt;p&gt;注意，如果要回滚数据库操作，一定要抛出运行时异常且不要有任何try catch此异常的代码。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;事务配置&lt;/h3&gt;

&lt;p&gt;假设你的数据源配置如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&amp;gt;
    &amp;lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driverClassName}&quot; /&amp;gt;
    &amp;lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&amp;gt;
    &amp;lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&amp;gt;
    &amp;lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;则只需添加下面的配置就可以使用spring提供的事务管理了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&amp;gt;
    &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;

&amp;lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&amp;gt;
    &amp;lt;tx:attributes&amp;gt;
        &amp;lt;tx:method name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;/&amp;gt;
        &amp;lt;tx:method name=&quot;onMessage&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;/&amp;gt;
        &amp;lt;tx:method name=&quot;*&quot; propagation=&quot;SUPPORTS&quot; read-only=&quot;true&quot;/&amp;gt;
    &amp;lt;/tx:attributes&amp;gt;
&amp;lt;/tx:advice&amp;gt;

&amp;lt;aop:config&amp;gt;
    &amp;lt;aop:pointcut id=&quot;txPointcut&quot; expression=&quot;
        execution(* com.lastww.service..*.*(..)) or
        execution(* com.lastww.listener..*.*(..))&quot;/&amp;gt;
    &amp;lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;txPointcut&quot;/&amp;gt;
&amp;lt;/aop:config&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;理解上面的配置需要懂点AOP，&lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/spring-framework-reference/html/aop.html&quot;&gt;点此了解&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;上面的配置是说，执行com.lastww.service包及其子包或者com.lastww.listener包及其子包的任何方法时启用事务管理。以update、onMessage开头的方法需要开启事务，其他方法事务以只读的方法执行。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;表达式语法&lt;/h3&gt;
&lt;p&gt;pointcut有：within、args、target等。其中用的最多的是execution， 执行表达式的模式必须符合：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;execution(modifiers-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;modifiers-pattern：修饰符，如public、protected&lt;/p&gt;

&lt;p&gt;ret-type-pattern：方法返回值类型&lt;/p&gt;

&lt;p&gt;declaring-type-pattern：&lt;em&gt;这个还不知道是什么&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;name-pattern：方法名模式&lt;/p&gt;

&lt;p&gt;param-pattern：参数模式，(..)代表所有参数,(*)代表一个参数,(*,String)代表第一个参数为任何值,第二个为String类型.&lt;/p&gt;

&lt;p&gt;throws-pattern：异常列表&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;http://docs.spring.io/spring/docs/current/spring-framework-reference/html/transaction.html&quot;&gt;Spring Transaction Management&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://sishuok.com/forum/posts/list/281.html&quot;&gt;AspectJ切入点语法详解&lt;/a&gt;&lt;/p&gt;

</description>
                <link>http://youly.github.io/2014/12/04/spring-transaction</link>
                <guid>http://youly.github.io/2014/12/04/spring-transaction</guid>
                <pubDate>2014-12-04T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>使用zookeeper实现动态配置管理</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;目标&lt;/h3&gt;
&lt;p&gt;1、在内存中存储一套配置，业务逻辑每次从JVM本地内存中读取配置然后执行相应逻辑&lt;/p&gt;

&lt;p&gt;2、修改配置，不重启JVM，业务逻辑下次读取配置时能感知到变化&lt;/p&gt;

&lt;p&gt;3、多个JVM能共享这套配置&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;实现&lt;/h3&gt;
&lt;p&gt;实现上述目标，可以把配置写在数据库中，每次修改配置，更新数据表相应字段即可。但若业务需频繁读取此配置，则会增加额外的性能开销。&lt;/p&gt;

&lt;p&gt;利用ZooKeeper的watcher机制能很好的实现上述目标：在zookeep中新建配置根节点，在根节点下初始化配置。虽然zookeeper支持类似文件系统的目录结构，但实现这套配置管理，只需支持根节点下面一层。每次有配置变更，重新加载所有配置，以减少内存中数据与zookeeper中数据不一致的可能。&lt;/p&gt;

&lt;p&gt;代码主要分成两部分：&lt;/p&gt;

&lt;p&gt;1、处理zookeeper连接断开、数据更新等事件通知，保证与zookeeper的连接始终有效：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Override
public void process(WatchedEvent event) {

    log.debug(&quot;received event:&quot; + event.toString());

    switch (event.getType()) {
        case None:
            switch (event.getState()) {
                case Expired:
                    log.debug(&quot;expired:&quot; + this.zooKeeper.getSessionId());
                    try {
                        this.zooKeeper.close();
                        this.zooKeeper = createZooKeeper();
                        this.monitor();
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                    break;
                case Disconnected:
                    log.debug(&quot;disconnected:&quot; + this.zooKeeper.getSessionId());
                    try {
                        this.zooKeeper.close();
                        this.zooKeeper = createZooKeeper();
                        this.monitor();
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                    break;
                case SyncConnected:
                    countDownLatch.countDown();
                    break;
            }
            break;
        case NodeChildrenChanged:
            //节点删除、创建同时会促发上层节点NodeChildrenChanged事件，因此可忽略
            //case NodeDeleted:
            //case NodeCreated:
        case NodeDataChanged:
            if (!this.zooKeeper.getState().isAlive()) {
                try {
                    this.zooKeeper = createZooKeeper();
                } catch (Exception e) {
                    throw new RuntimeException(e);
                }
            }
            this.monitor();
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;2、加载配置数据并重新注册watcher：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public void monitor() {
        //更新数据并注册watcher
        try {
            // 监听根节点数据变更、创建、删除
            this.zooKeeper.getData(&quot;/root&quot;, true, null);
            // 监听子节点数据更新、创建、删除
            List&amp;lt;String&amp;gt; children = this.zooKeeper.getChildren(&quot;/root&quot;, true);
            for (String child : children) {
                this.zooKeeper.getData(&quot;/root/&quot; + child, true, null);
            }
        } catch (KeeperException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;完整代码点&lt;a href=&quot;https://github.com/youly/study/blob/master/src/main/java/com/lastww/study/zookeeper/ZookeeperEventContainer.java&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;zookeeper&quot;&gt;使用zookeeper需注意的几点&lt;/h3&gt;

&lt;p&gt;1、收到zookeeper节点数据变更事件后需要重新注册watcher，否则之后不会再收到通知&lt;/p&gt;

&lt;p&gt;2、与zookeeper的连接断开后，在session timeout之前可以重新连接&lt;/p&gt;

&lt;p&gt;3、节点的版本变更后，即使数据不变，也会收到通知&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;http://jm-blog.aliapp.com/?p=1384&quot;&gt;ZooKeeper FAQ&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、https://cwiki.apache.org/confluence/display/ZOOKEEPER/FAQ&lt;/p&gt;

</description>
                <link>http://youly.github.io/2014/11/28/zookeeper-confighub</link>
                <guid>http://youly.github.io/2014/11/28/zookeeper-confighub</guid>
                <pubDate>2014-11-28T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>jvm本地缓存的实现</title>
                <description>&lt;h3 id=&quot;remotecachelocalcache&quot;&gt;是remotecache，而不是localcache&lt;/h3&gt;

&lt;p&gt;今日做微信支付接入时有个问题是，每次请求生成预付款订单时都得带上一个access_token。虽然不知道这个access_token是否真的有必要，但这种做法与支付宝支付接入相比，明显是增加了麻烦。根据微信的文档，获得的这个access_token是有个过期时间的，意思是开发者得自己缓存这个token，否则每次去调用刷新将增加额外的网络开销。&lt;/p&gt;

&lt;p&gt;那么如何缓存这个token呢？当前我们使用的框架实现了localcache，只要继承这个localcache就可以在jvm内存中缓存这个token，每次客户端请求支付时直接从内存中取，取出来的时候先判断下是否过期，如果过期才去微信接口重新获取再缓存。想起来是个不错的解决方案，于是马上写代码实现之。写完之后细想，我们的web程序是部署在多台机器上通过nginx分发流量的，即使用了多个jvm，每个jvm都有自己的localcache，客户端请求支付时都会去调用微信接口获取access_token。而文档里又写着，每调用一次，之前获取的将token失效。这搞毛线，jvm之间互相使对方失效，完美的cache计划泡汤了…&lt;/p&gt;

&lt;h3 id=&quot;localcache&quot;&gt;说说localcache&lt;/h3&gt;

&lt;p&gt;上面的问题有很多解决方案，比如使用redis集中式cache、dbcache等。但接下来要讲的是localcache，毕竟这个是今天遇到的一个坑。&lt;/p&gt;

&lt;p&gt;localcache相对于集中式cache有几个优点，比如：&lt;/p&gt;

&lt;p&gt;1、直接内存访问，速度快，没有网络开销&lt;/p&gt;

&lt;p&gt;2、便于管理，没有数据同步的烦恼&lt;/p&gt;

&lt;p&gt;通常在业务数据不是很敏感或者敏感度低的时候，很适合使用localcahce。比如我们现在的首页，商品基本上是每天十点加载并缓存，之后很少就会有更新了。即使有更新，延迟一点点刷新也没有问题。&lt;/p&gt;

&lt;h3 id=&quot;localcache-1&quot;&gt;localcache的实现&lt;/h3&gt;

&lt;p&gt;实现一个localcache，实现以下三个对象就可以：&lt;/p&gt;

&lt;p&gt;1、LocalCacheWraper，与具体业务关联的对象，提供访问localcache的接口，并封装一些业务逻辑，如判断缓存是否已失效等。&lt;/p&gt;

&lt;p&gt;2、AbstractLocalCache，提供对象cache，从其他数据源加载数据，能再高并发的场景下原子性的get，load，reload，&lt;/p&gt;

&lt;p&gt;3、LocalCacheManager，管理对象cache，负责定时reload缓存、接收外部消息更新缓存&lt;/p&gt;

&lt;p&gt;上代码，AbstractLocalCache实现&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;

public abstract class AbstractLocalCache&amp;lt;T&amp;gt; {

    private final AtomicReference&amp;lt;T&amp;gt; objectRef;

    private final AtomicBoolean isLoad;

    public AbstractLocalCache() {
        super();
        this.objectRef = new AtomicReference&amp;lt;&amp;gt;();
        this.isLoad = new AtomicBoolean(false);
        if (!isLazy()) {
            init();
        }
    }

    /**
     * 缓存初始化
     */
    protected void init() {
        if (isLoad.get()) {
            return;
        }

        synchronized (init) {
            if (isLoad.get()) {
                return;
            }
            T object = load();
            this.objectRef.set(object);
            LocalCacheManager.getInstance().register(this);
            isLoad.set(true);
        }
    }

    /**
     * 收到数据更新广播，重新加载数据
     */
    public void onMessage(Object message) {
        reload();
    }

    /**
     * 缓存初始化
     */
    public T get() {
        init();
        return objectRef.get();
    }

    /**
     * 重新加载缓存
     */
    public void reload() {
        T object = load();
        this.objectRef.set(object);
    }

    /**
     * 定时刷新间隔，由子类实现
     */
    abstract public long getReloadPeriod();

    /**
     * 是否延迟加载，由子类实现
     */
    abstract public boolean isLazy();

    /**
     * 从数据源加载缓存，由子类实现
     */
    abstract public boolean load();

    /**
     * 订阅消息key，由子类实现
     */
    abstract public boolean key();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;LocalCacheManager实现：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

public class LocalCacheManager {

    private static final LocalCacheManager INSTANCE = new LocalCacheManager();

    public static LocalCacheManager getInstance() {
        return INSTANCE;
    }

    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(8);

    private final ConcurrentHashMap&amp;lt;String, LocalCache&amp;lt;?&amp;gt;&amp;gt; localCacheMap = new ConcurrentHashMap&amp;lt;&amp;gt;();

    private LocalCacheManager() {
    }

    /**
     * 注册cache
     */
    public void register(LocalCache&amp;lt;?&amp;gt; localCache) {

        localCacheMap.putIfAbsent(localCache.key(), localCache);
        scheduleReload(localCache);
        scribeReloadMessage(localCache);
    }


    /**
     * 线程池固定间隔调度，刷新cache
     */
    public void scheduleReload(final LocalCache&amp;lt;?&amp;gt; localCache) {
        scheduler.scheduleWithFixedDelay(new Runnable() {

            @Override
            public void run() {
                localCache.reload();
            }
        }, localCache.getReloadPeriod(), localCache.getReloadPeriod(), TimeUnit.MILLISECONDS);
    }

    /**
     * 基于zookeeper实现的发布订阅服务，跨jvm之间同步缓存
     */
    public void scribeReloadMessage(final LocalCache&amp;lt;?&amp;gt; localCache) {
        ZookeeperPubSubService.getInstance().register(localCache.key(), localCache);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的manager类实现了多jvm之间同步cache，其实可以解决最初的问题，但localcache毕竟不是为适用这种场景而设计的，远没有remotecache可靠。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;http://blog.csdn.net/cenwenchu79/article/details/6076513&quot;&gt;Local Cache的小TIP&lt;/a&gt;&lt;/p&gt;

</description>
                <link>http://youly.github.io/2014/11/18/jvm-local-cache</link>
                <guid>http://youly.github.io/2014/11/18/jvm-local-cache</guid>
                <pubDate>2014-11-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>计算机编码</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;遇到的情况&lt;/h3&gt;
&lt;p&gt;用户给商品添加评价，结果报错：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;uncategorized SQLException for SQL []; SQL state [HY000]; error code [1366]; Incorrect string value: '\xF0\x9F\x8E\x81\xE7\x9A...'
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;java后端采用utf8编码，mysql也采用utf8编码，都正常，怎么会报错呢？&lt;/p&gt;

&lt;p&gt;先来看看 '\xF0\x9F\x8E\x81\xE7\x9A…'是什么：&lt;/p&gt;

&lt;p&gt;使用python，将字节还原成unicode编码，然后再打印出来：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/unicode.png&quot; alt=&quot;unicode&quot; /&gt;&lt;/p&gt;

&lt;p&gt;去&lt;a href=&quot;http://www.utf8-chartable.de/unicode-utf8-table.pl&quot;&gt;这里&lt;/a&gt;查询知道，\U0001f381 代表 WRAPPED PRESENT，以utf8编码后16进制为：f0 9f 8e 81， 长度为四个字节，再去mysql官网&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.5/en/charset-unicode-utf8.html&quot;&gt;查询&lt;/a&gt;, mysql的utf8编码实际仅仅支持最多3个字节的编码！&lt;/p&gt;

&lt;p&gt;如何解决这个问题呢？可以设置Mysql服务器编码为utf8mb4，也可以在业务层过滤掉超过四个字节的编码。&lt;/p&gt;

&lt;p&gt;把unicode范围\u0000-\uFFFF内的字符替换掉，来自stackoversflow的&lt;a href=&quot;http://stackoverflow.com/questions/14981109/checking-utf-8-data-type-3-byte-or-4-byte-unicode&quot;&gt;代码&lt;/a&gt;：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static String withNonBmpStripped( String input ) {
        if( input == null ) throw new IllegalArgumentException(&quot;input&quot;);
            return input.replaceAll(&quot;[^\\u0000-\\uFFFF]&quot;, &quot;&quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者使用java内置的方法：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static boolean isEntirelyInBasicMultilingualPlane(String text) {
    for (int i = 0; i &amp;lt; text.length(); i++) {
        if (Character.isSurrogate(text.charAt(i))) {
            return false;
        }
    }
    return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;什么是编码&lt;/h3&gt;

&lt;p&gt;信息是什么？对计算机来说，是一系列的0、1串，而对于人来说，则是一系列可以理解的数字、符号、表情等。&lt;/p&gt;

&lt;p&gt;所谓编码(codec)，是以某种规则（映射关系）把信息从一种形式对应到另外一种形式的过程。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;字符集&lt;/h3&gt;
&lt;p&gt;字符集，信息表示形式的集合。字符集的概念依托于编码(codec)，有了编码才会有字符集。每种编码都有一个有限的表示集合。比如二进制编码的字符集是{0, 1}，gbk编码的字符集是一系列的中文符号。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;二进制文件与文本文件&lt;/h3&gt;
&lt;p&gt;二进制文件可以包含任何形式的数据，比如图形、声音，以二进制编码。&lt;/p&gt;

&lt;p&gt;文本文件是某种字符编码的文件，仅仅包含这个编码字符集内的字符，例如ASCII文本文件里面不会出现超过127的字符。&lt;/p&gt;

&lt;h3 id=&quot;unicodeutf-8utf-16&quot;&gt;Unicode与UTF-8、UTF-16&lt;/h3&gt;
&lt;p&gt;Unicode， 统一（唯一）编码，能表示所有字符的字符集，不仅仅局限于某国语言。&lt;/p&gt;

&lt;p&gt;Unicode仅仅是一个概念，不能被电脑表示、不能用来传输，于是就有了UTF(Unicode Transfer Format)，将unicode安装某种规则转换成1到6个字节。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;源文件编码&lt;/h3&gt;
&lt;p&gt;源文件编码(source code encode)， 由操作系统默认编码和编辑器决定。编写完代码点击保存时，编辑器会以特定的编码（通常是操作系统默认编码）来保存文件。&lt;/p&gt;

&lt;p&gt;有的编辑器会在源文件开头增加编码标识，以便读取时以此种编码标识解码。&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;运行时编码&lt;/h3&gt;
&lt;p&gt;程序运行时采用的一种编码，相对程序来说，通常与源文件编码不同。如python运行时以unicode来表示所有的字符。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;http://pythonic.zoomquiet.io/data/20110415091609/index.html&quot;&gt;All About Python and Unicode&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://www.utf8-chartable.de/unicode-utf8-table.pl&quot;&gt;Unicode-utf8字符表&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;http://en.wikipedia.org/wiki/Plane_(Unicode)&quot;&gt;Wikipedia:Plane_Unicode&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4、&lt;a href=&quot;http://dev.mysql.com/doc/refman/5.5/en/charset-unicode-utf8.html&quot;&gt;Mysql The utf8 Character Set (3-Byte UTF-8 Unicode Encoding)&lt;/a&gt;&lt;/p&gt;

</description>
                <link>http://youly.github.io/2014/11/07/computer-codec</link>
                <guid>http://youly.github.io/2014/11/07/computer-codec</guid>
                <pubDate>2014-11-07T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>网络基础-bridge和tunnel</title>
                <description>&lt;h3 id=&quot;bridge&quot;&gt;什么是bridge&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;概念&lt;/h4&gt;
&lt;p&gt;桥，字面上可以理解为连接两个不同网络段的“桥梁”，但实际上最开始是为了划分网络段，隔离冲突域。&lt;/p&gt;

&lt;p&gt;以太网中数据包以广播的形式发送，每台设备收到数据包后需要判断这个包是否是发给自己的，如果目标mac地址与自己的相同，则接受数据包、然后流向网络层，否则丢弃。由于所有设备共享网络传输介质，导致了如果多台设备同时发送数据包则会引发冲突。一旦设备过多，整个网络传输效率就变得低下。为了减少冲突的发生，出现了桥接器，将一个大的网络分离成两个小的网络，数据包到达桥接器时会以mac地址来判断是否要继续广播。这里桥接器内部维护一个mac地址与端口的映射表，通过多次的数据广播学习而得。&lt;/p&gt;

&lt;p&gt;桥接器工作于OSI模型中的链路层，交换机可以理解为有多个的端口的桥接器，连接多个不同的网段。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;应用&lt;/h4&gt;
&lt;p&gt;创建一个需要上网的虚拟机，而系统只有一个网卡，这时候虚拟交换机就派上用场了。linux里自带了一个bridge内核模块，设置可参考：&lt;a href=&quot;https://wiki.archlinux.org/index.php/Network_bridge&quot;&gt;https://wiki.archlinux.org/index.php/Network_bridge&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;tunnel&quot;&gt;什么是tunnel&lt;/h3&gt;

&lt;h4 id=&quot;section-2&quot;&gt;概念&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Tunneling_protocol&quot;&gt;隧道&lt;/a&gt;，在原有的传输层协议上对数据包的自定义协议封装。比较广泛的是ip tunnel，在ip（公网地址）协议之上传输ip（私有地址）数据包。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;应用&lt;/h4&gt;
&lt;p&gt;ssh端口转发、openvpn&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;http://kovyrin.net/2006/03/17/how-to-create-ip-ip-tunnel-between-freebsd-and-linux/&quot;&gt;在freebsd和linux之间创建ip-ip tuannel&lt;/a&gt;&lt;/p&gt;

</description>
                <link>http://youly.github.io/2014/10/19/bridge-tunnel</link>
                <guid>http://youly.github.io/2014/10/19/bridge-tunnel</guid>
                <pubDate>2014-10-19T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>https通信原理</title>
                <description>&lt;h3 id=&quot;https&quot;&gt;什么是https&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/HTTP_Secure&quot;&gt;https&lt;/a&gt;，简单的说就是HTTP协议+SSL协议。由于使用HTTP协议传输的数据没有加密，有可能被第三方窃取甚至修改，Netscape公司于1994年创造了https。SSL协议在通信过程中起了两个作用：&lt;/p&gt;

&lt;p&gt;1、确保通信双方身份没有伪造，通过数字证书实现。&lt;/p&gt;

&lt;p&gt;2、确保与服务器之间的通讯不能被第三方窃取、修改。&lt;/p&gt;

&lt;p&gt;了解https通信过程还需知道两种加密方式：非对称加密和对称加密。客户端与服务器进行安全数据交互之前，需在非对称秘钥的加密保护下生成用于会话期数据加密的对称秘钥。&lt;/p&gt;

&lt;h3 id=&quot;ssl&quot;&gt;SSL连接建立过程&lt;/h3&gt;
&lt;p&gt;客户端和服务器交换数据之前有个握手协议，具体过程是：&lt;/p&gt;

&lt;p&gt;1、客户端初始化支持的加密算法、压缩算法、SSL协议版本，并向服务器发起消息结构体为client hello的连接&lt;/p&gt;

&lt;p&gt;2、服务端收到消息，根据客户端提供的加密算法列表、压缩算法列表来选取后续使用的对称加密算法、压缩算法和SSL协议版本，并返回结构体为server hello的消息。&lt;/p&gt;

&lt;p&gt;3、如果客户端需要服务器身份认证，服务器在返回server hello的消息后需立刻返回数字证书信息（通常服务器认证是必须的），并发送hello done的消息。&lt;/p&gt;

&lt;p&gt;4、客户端验证证书是否有效，并发送用证书公钥加密的对称秘钥。&lt;/p&gt;

&lt;p&gt;5、服务器收到加密的对称秘钥，使用自己的私钥解密，并发送通过对称秘钥加密的的会话完成信息。&lt;/p&gt;

&lt;p&gt;握手完成之后客户端和服务器可以安全交换信息了。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;什么是数字证书&lt;/h3&gt;
&lt;p&gt;数字证书之于服务器，就像身份证之于人。数字证书由被公认的证书机构颁发。通常操作系统里都会内置一些知名证书机构的根证书。证书内容由以下几个部分组成（&lt;a href=&quot;http://en.wikipedia.org/wiki/Public_key_certificate&quot;&gt;来自wikipedia&lt;/a&gt;）：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Serial Number: Used to uniquely identify the certificate.
&lt;br /&gt;Subject: The person, or entity identified.
&lt;br /&gt;Signature Algorithm: The algorithm used to create the signature.
&lt;br /&gt;Signature: The actual signature to verify that it came from the issuer.
&lt;br /&gt;Issuer: The entity that verified the information and issued the certificate.
&lt;br /&gt;Valid-From: The date the certificate is first valid from.
&lt;br /&gt;Valid-To: The expiration date.
&lt;br /&gt;Key-Usage: Purpose of the public key (e.g. encipherment, signature, certificate signing…).
&lt;br /&gt;Public Key: The public key.
&lt;br /&gt;Thumbprint Algorithm: The algorithm used to hash the public key certificate.
&lt;br /&gt;Thumbprint (also known as fingerprint): The hash itself, used as an abbreviated form of the public key certificate.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;从上面的引用中知道，证书主要由三部分组成：证书内容、证书签名、证书指纹。那么拿到一个证书，如何验证证书的有效性呢？先看下面的一幅图：
&lt;img src=&quot;/assets/images/digtal_certificate_sign.png&quot; alt=&quot;签名和认证&quot; /&gt;&lt;/p&gt;

&lt;p&gt;颁发证书的机构会将证书内容使用指定的哈希函数生成内容hash，然后用自己的私钥加密哈希形成签名。证书指纹用于确定证书没有被修改。解密验证过程如上右图，如果最终得到的签名与客户端使用指定的签名算法得到的签名不一致，则证书是不可信的。&lt;/p&gt;

&lt;p&gt;一般我们得到的证书都不是根证书机构直接颁发的，而是经过了中间机构。这里有一个信任链机制，客户端或从证书链的底端逐级网上找到根证书颁发机构，然后使用颁发机构的公钥逐级往下验证证书的有效性，过程如下图：
&lt;img src=&quot;/assets/images/digtal_certificate_sign1.gif&quot; alt=&quot;证书链&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;http://robertheaton.com/2014/03/27/how-does-https-actually-work/&quot;&gt;How does HTTPS actually work?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://en.wikipedia.org/wiki/HTTP_Secure&quot;&gt;WikiPedia:HTTP_Secure&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3、&lt;a href=&quot;http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html&quot;&gt;数字证书原理&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;4、&lt;a href=&quot;http://prefetch.net/articles/debuggingssl.html&quot;&gt;Debugging SSL communications&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;5、&lt;a href=&quot;http://www.ibm.com/developerworks/cn/linux/l-cn-sclient/&quot;&gt;应用 openssl 工具进行 SSL 故障分析&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;6、&lt;a href=&quot;http://lukejin.iteye.com/blog/587200&quot;&gt;证书链(The Certificate Chains)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;7、&lt;a href=&quot;http://www.akadia.com/services/ssh_test_certificate.html&quot;&gt;How to create a self-signed SSL Certificate&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://youly.github.io/2014/07/09/how-does-https-work</link>
                <guid>http://youly.github.io/2014/07/09/how-does-https-work</guid>
                <pubDate>2014-07-09T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>thrift简单使用</title>
                <description>&lt;h3 id=&quot;thrift&quot;&gt;什么是thrift&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://thrift.apache.org/&quot;&gt;官网&lt;/a&gt;上介绍：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The Apache Thrift software framework, for scalable cross-language services development, combines a software stack with a code generation engine to build services that work efficiently and seamlessly between C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, OCaml and Delphi and other languages.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;通常当网站达到一定规模时，单种编程语言已经无法满足最佳实践了。由于业务的需要，不同模块之间需建立一个简单稳定的数据交换通道。&lt;a href=&quot;http://en.wikipedia.org/wiki/SOAP&quot;&gt;SOAP&lt;/a&gt;是Web Services之间的交换结构化信息的一种协议，类似地thrift是实现本地程序之间交换数据的一种接口定义。&lt;/p&gt;

&lt;h3 id=&quot;thirft&quot;&gt;thirft网络架构&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://thrift.apache.org/docs/concepts/&quot;&gt;来自这里&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; +-------------------------------------------+
  | Server                                    |
  | (single-threaded, event-driven etc)       |
  +-------------------------------------------+
  | Processor                                 |
  | (compiler generated)                      |
  +-------------------------------------------+
  | Protocol                                  |
  | (JSON, compact etc)                       |
  +-------------------------------------------+
  | Transport                                 |
  | (raw TCP, HTTP etc)                       |
  +-------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Transport：负责读写数据，不管数据来源于套接字、内存还是文件。&lt;/p&gt;

&lt;p&gt;Protocol：负责解析数据，client按此种格式encode，server端按此种格式decode。&lt;/p&gt;

&lt;p&gt;Processor：负责执行远过程调用。&lt;/p&gt;

&lt;p&gt;Server：具体的程序逻辑，负责创建Transport、Protocol、Processor，等待客户端连接并响应。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;http://diwakergupta.github.io/thrift-missing-guide/#_versioning_compatibility&quot;&gt;Thrift: The Missing Guide&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://thrift.apache.org/static/files/thrift-20070401.pdf&quot;&gt;Thrift: Scalable Cross-Language Services Implementation&lt;/a&gt;&lt;/p&gt;

</description>
                <link>http://youly.github.io/2014/03/08/simple-thrift-usage</link>
                <guid>http://youly.github.io/2014/03/08/simple-thrift-usage</guid>
                <pubDate>2014-03-08T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>后缀表达式与中缀表达式相互转换</title>
                <description>&lt;p&gt;最近做对账平台的动态配置时，有一个解析表达式的需求。在页面输入一个表达式，比如(sysno-outno，100*money)，系统可根据表达式的类型来决定求其值还是仅仅替换掉变量。刚开始想到用php的eval函数，输入’100*3’，eval(‘100*3’)马上就能得到结果，但当输入’sysno-outno’这种需替换变量时就显得很不方便了,还是得解析下表达式。&lt;/p&gt;

&lt;p&gt;最初想到了前缀表达式，简单且能快速实现。例如用户配置某个字段的值等于100*(a+b),则输入&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[&quot;*&quot;,[100,[&quot;+&quot;,[&quot;a&quot;,&quot;b&quot;]]]]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;后台先json_decode,然后使用递归马上就能解析到其字符串形式。然而这样方便了自己，但给用户配置带来了不少困难。想到最终的系统应该是简单易用，还是得想想其他的方法。如果使用后缀表达式呢？用户直接输入中缀表达式，后台将其转换成后缀表达式，再重新拼装成所需的字符串形式的中缀表达式。&lt;/p&gt;

&lt;p&gt;这个过程主要的难点是怎样把中缀表达式转换成&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95&quot;&gt;后缀表达式&lt;/a&gt;。以我的理解，后缀表达式即两个操作数在前，操作符在后。转换的过程可以简单的表述如下：&lt;em&gt;初始化两个栈，操作数栈s1和操作符栈s2，从左往右遍历中缀表达式，遇到操作数入栈s1，遇到右括号，或者是其他符号并且比当前s2栈顶符号的优先级低，则将s2栈顶符号弹出并入栈s1，并将当前符号入栈s2（我的理解：符号优先级越高，则其越靠近栈顶，优先参与运算），重复以上操作直到结束。最终的s1元素即为所求后缀表达式&lt;/em&gt;。&lt;/p&gt;

&lt;p&gt;使用php实现如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*
 * 后缀表达式与中缀表达式相互转换的一个简单实现
 */

class Formula
{
    /** 操作符列表 */
    private static $operator = array('(', ')', '+', '-', '*', '/');
    /** 算法优先级，数字越大则优先级越高 */
    private static $priority = array('#' =&amp;gt; 0, '(' =&amp;gt; 10, '+' =&amp;gt; 20, '-' =&amp;gt; 20, '*' =&amp;gt; 30, '/' =&amp;gt; 30);

    /**
     * @brief 字符串表达式转换成逆波兰式
     * @expression String
     * @return Array
     */
    public static function exp2rpn($expression)
    {
        /** 操作符栈 */
        $operator_stack = array('#');
        /** 操作数栈 */
        $operand_stack = array();
        $len = strlen($expression);
        $word = '';
        for ($i = 0; $i &amp;lt; $len; $i++) {
            $char = substr($expression, $i, 1);
            if (!in_array($char, self::$operator)) {
                $word .= $char;
                continue;
            }
            if (!empty($word)) {
                array_push($operand_stack, $word);
                $word = '';
            }
            if ($char == '(') {
                array_push($operator_stack, $char);
                continue;
            } else if ($char == ')') {
                while (count($operator_stack)) {
                    $lex = array_pop($operator_stack);
                    if ($lex == '(') {
                        break;
                    } else {
                        array_push($operand_stack, $lex);
                    }
                }
                continue;
            } else if (self::$priority[$char] &amp;lt;= self::$priority[end($operator_stack)]) {
                array_push($operand_stack, array_pop($operator_stack));
                array_push($operator_stack, $char);
                continue;
            } else {
                array_push($operator_stack, $char);
                continue;
            }
        }
        /* 最后一个操作数入栈 */
        array_push($operand_stack, $word);
        while (count($operator_stack)) {
            if (end($operator_stack) == '#') {
                break;
            }
            array_push($operand_stack, array_pop($operator_stack));
        }
        return $operand_stack;
    }

    /**
     * @brief 将逆波兰式转换成字符串的表达式
     * @rpn Array 波兰式数组
     * @withC Boolean 输出结果是否带括号
     * @return String
     */
    public static function rpn2exp($rpn, $withC = true)
    {
        if (!is_array($rpn)) {
            return '';
        }
        $stack = array();
        $len = count($rpn);
        for ($i = 0; $i &amp;lt; $len; $i++) {
            if (in_array($rpn[$i], self::$operator)) {
                $operator = $rpn[$i];
                $right_operand = array_pop($stack);
                $left_operand = array_pop($stack);
                $res = $left_operand . $operator . $right_operand;
                if ($withC) {
                    $res = '(' . $res . ')';
                }
                array_push($stack, $res);
            } else {
                array_push($stack, $rpn[$i]);
            }
        }
        return current($stack);
    }

    /*
     * @brief 将表达式中指定变量替换成数值
     * @exp String 字符串表达式
     * @fields Array 包含变量的关联数组
     * @withC boolean 输出结果是否带括号
     * @return String
     */
    public static function exp_replace($exp, $fields, $withC = false)
    {
        $rpn = self::exp2rpn($exp);
        $stack = array();
        $len = count($rpn);
        for ($i = 0; $i &amp;lt; $len; $i++) {
            if (in_array($rpn[$i], self::$operator)) {
                $operator = $rpn[$i];
                $right_operand = array_pop($stack);
                $left_operand = array_pop($stack);
                if (isset($fields[$right_operand])) {
                    $right_operand = $fields[$right_operand];
                }
                if (isset($fields[$left_operand])) {
                    $left_operand = $fields[$left_operand];
                }
                $res = $left_operand . $operator . $right_operand;
                if ($withC) {
                    $res = '(' . $res . ')';
                }
                array_push($stack, $res);
            } else {
                array_push($stack, $rpn[$i]);
            }
        }
        return current($stack);
    }
}

$exp = '(10*(sysno+outno)-a/b)*c';
$r = Formula::exp2rpn($exp);
var_dump($r);
$a = Formula::rpn2exp($r, true);
var_dump($a);
$a = Formula::exp_replace('sysno-outno', array('sysno' =&amp;gt; '2323232', 'outno' =&amp;gt; '998979'));
var_dump($a);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;http://zhouliang.pro/2013/08/18/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/&quot;&gt;波兰式、逆波兰式与表达式求值&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95&quot;&gt;逆波兰表示法&lt;/a&gt;&lt;/p&gt;

</description>
                <link>http://youly.github.io/2014/02/27/reverse-polish-notation</link>
                <guid>http://youly.github.io/2014/02/27/reverse-polish-notation</guid>
                <pubDate>2014-02-27T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>《High Performance Mysql》学习笔记</title>
                <description>&lt;ol&gt;
  &lt;li&gt;Any operation that changes an innodb table’s structure will rebuild the entire table,including all the indexes;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2.InnoDB tables are built on a clustered index,As a result, it provides very fast primary key lookups. How- ever, secondary indexes (indexes that aren’t the primary key) contain the primary key columns, so if your primary key is large, other indexes will also be large.&lt;/p&gt;

&lt;p&gt;3.Simply put, a phantom read can happen when you select some range of rows, another transaction inserts a new row into the range, and then you select the same range again; you will then see the new “phantom” row.&lt;/p&gt;

&lt;p&gt;4.A benchmark measures your system’s perfor- mance. This can help determine a system’s capacity, show you which changes mat- ter and which don’t, or show how your application performs with different data.In contrast, profiling helps you find where your application spends the most time or consumes the most resources. In other words, benchmarking answers the question “How well does this perform?” and profiling answers the question “Why does it perform the way it does?”.&lt;/p&gt;

&lt;p&gt;5.Choosing Optimal Data Types:Smaller is usually better,Simple is good,Avoid NULL if possible.It’s harder for MySQL to optimize queries that refer to nullable columns, because they make indexes, index statistics, and value comparisons more com- plicated. A nullable column uses more storage space and requires special pro- cessing inside MySQL.&lt;/p&gt;

&lt;p&gt;6.MySQL lets you specify a “width” for integer types, such as INT(11). This is mean- ingless for most applications: it does not restrict the legal range of values, but simply specifies the number of characters MySQL’s interactive tools (such as the command- line client) will reserve for display purposes. For storage and computational pur- poses, INT(1) is identical to INT(20).&lt;/p&gt;

&lt;p&gt;7.DECIMAL was just a storage format; DECIMAL numbers were converted to DOUBLEs for computational purposes.Because of the additional space requirements and computational cost, you should use DECIMAL only when you need exact results for fractional numbers—for example, when storing financial data.&lt;/p&gt;

&lt;p&gt;8.In MySQL, the simplest query cost metrics are:&lt;/p&gt;

&lt;p&gt;• Execution time&lt;/p&gt;

&lt;p&gt;• Number of rows examined&lt;/p&gt;

&lt;p&gt;• Number of rows returned&lt;/p&gt;
</description>
                <link>http://youly.github.io/2013/08/19/notes-of-high-performance-mysql</link>
                <guid>http://youly.github.io/2013/08/19/notes-of-high-performance-mysql</guid>
                <pubDate>2013-08-19T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>基于php、mysql实现的对象关系映射</title>
                <description>&lt;h3 id=&quot;orm&quot;&gt;什么是ORM&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Object-relational_mapping&quot;&gt;ORM&lt;/a&gt;的全称是Object Relational Mapping,以面向对象的方式来访问存储在关系型数据库里的信息。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;简单实现&lt;/h3&gt;

&lt;h4 id=&quot;obj-&quot;&gt;1、Obj-数据模型抽象&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;abstract class Obj
{
	//对应数据库中列属性
	protected $propTable;
	//对象是否加载，新建则false，从数据库中load则true
	protected $isLoad;

	public function __construct($arg = null)
	{
		if(is_null($arg)) {
			$this-&amp;gt;init();
		} else {
			$this-&amp;gt;load($arg);
		}
	}

	//魔法方法，访问不存在的属性时系统自动调用此函数
	public function __set($name, $value)
	{
		if(isset($this-&amp;gt;propTable[$name])) {
			$this-&amp;gt;propTable[$name] = $value;
		} else {
			error_log('field not found!');
		}
	}

	public function __get($name)
	{
		if(isset($this-&amp;gt;propTable[$name])) {
			return $this-&amp;gt;propTable[$name];
		} else {
			error_log('field not found!');
		}
	}

	public function init()
	{
		$conn = $this-&amp;gt;db-&amp;gt;getConn();
		/*
		//获取列类型信息
		$sql = 'selecct * from $this-&amp;gt;tableName limit 0;';
		$stmt = $conn-&amp;gt;prepare($sql);
		$stmt-&amp;gt;execute();
		$rs = $stmt-&amp;gt;result_metadata(); 
		$arr = array();
		while($field = $rs-&amp;gt;fetch_field())
		{
			$arr[$field-&amp;gt;name] = $field-&amp;gt;def;
		}
		$rs-&amp;gt;free_result();
		$stmt-&amp;gt;close();
		*/
		//获取列默认值
		$sql = 'desc $this-&amp;gt;tableName;'
		$rs = $conn-&amp;gt;query($sql); 
		foreach($rs as $val)
		{
			$key = $val['field'];
			$def = $val['default'];
			if(isset($arr[$key])) {
				$arr[$key] = $def;
			}
		}
		$this-&amp;gt;propTable = $arr;
		$this-&amp;gt;isLoad = false;
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;dbobj-&quot;&gt;2、DBObj-数据库操作类&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;abstract class DBObj extends Obj
{
	protected $tableName;

	protected $db;

	protected $connUrl;

	protected $primaryKey;

	public function __construct($arg)
	{
		$this-&amp;gt;db = DB::getInstance($this-&amp;gt;connUrl);
		parent::__construct($arg);
	}

	public function load($arg)
	{
		//为简单起见，传入$arg默认为主键
		$sql = &quot;select * from $this-&amp;gt;table where $this-&amp;gt;primaryKey=$arg;&quot;;
		$stmt = $conn-&amp;gt;prepare($sql);
		$stmt-&amp;gt;execute();
		if(is_null($this-&amp;gt;propTable)) {
			$this-&amp;gt;init();
		}
		$row = array();
		$keys = array_keys($this-&amp;gt;propTable);
		foreach($keys as $key)
		{
			$eval[] = '$row[&quot;' . $key . '&quot;]';
		}
		eval('$stmt-&amp;gt;bind_result(' . implode(',', $eval) . ');');
		$stmt-&amp;gt;fetch();
		foreach($row as $key =&amp;gt; $val)
		{
			$this-&amp;gt;propTable[$key] = $val;
		}
		$stmt-&amp;gt;free_result;
		$this-&amp;gt;isLoad = true;
	}

	public function update()
	{
		//将对象信息存入数据库
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;db-&quot;&gt;3、DB-数据库连接类&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class DB
{
	protected $connConfig;

	public function __construct($connUrl)
	{
		$this-&amp;gt;connConfig = $this-&amp;gt;parseUrl($connUrl);
	}

	public function getConn()
	{
		$conn = mysqli_init();
		@$conn-&amp;gt;real_connect(
			$this-&amp;gt;connConfig['host'],
			$this-&amp;gt;connConfig['user'], 
			$this-&amp;gt;connConfig['password'],
			$this-&amp;gt;connConfig['database'],
			$this-&amp;gt;connConfig['port']
		);
		$conn-&amp;gt;query('set names '' . $arg['charset']);
		return $conn;
	}

	public function parseUrl()
	{
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;可以改进的地方&lt;/h3&gt;

&lt;p&gt;1、由于列属性频繁别访问，可以对整个属性表加以缓存。缓存的实现方式有：类静态变量、xcache缓存&lt;/p&gt;

&lt;p&gt;2、对于频繁调用的方法加以缓存。实现方式有：以类名、方法名、方法参数为key、函数返回值为value，缓存于memcache中。&lt;/p&gt;

&lt;p&gt;3、update数据入库是对字段进行过滤。&lt;/p&gt;
</description>
                <link>http://youly.github.io/2013/08/14/php-mysql-orm</link>
                <guid>http://youly.github.io/2013/08/14/php-mysql-orm</guid>
                <pubDate>2013-08-14T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>一个简单的php-mvc框架实现</title>
                <description>&lt;h3 id=&quot;mvc&quot;&gt;什么是MVC&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Model-view-controller&quot;&gt;维基介绍&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;MVC是软件工程中的一种架构模式，成功地使用这种模式能够将复杂的业务逻辑和视图分离开，不仅能简化编码复杂度，还能减少代码重复量，提高编程效率。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;M-Model， 处理数据库逻辑，关系实体映射。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;V-View， 处理与用户直接相关的界面逻辑。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;C-Controller， 处理具体的业务逻辑。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在实际的MVC框架中可能还会有Action，在调用controller的方法之前由它先处理权限、Cookie等问题。controller在这种设计中可以看成java的类库，封装一些业务逻辑或算法供action调用。&lt;/p&gt;

&lt;p&gt;###实现一个简单的框架
***
####目录结构与命名规范&lt;/p&gt;

&lt;p&gt;首先框架应该有一个良好的目录结构以及命名规范。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/directory.png&quot; alt=&quot;目录结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上图是参考rails的目录结构稍作了点修改，去掉了那些我觉得暂时还不需要的，每个目录的作用如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;app-具体应用程序的逻辑。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;config-服务器/数据库/缓存等的具体配置&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;db-数据库的备份&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;lib-框架代码&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;public-静态HTML页面及一些css、images、js等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;script-存放一些后台执行的命令行脚本&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;tmp-存放一些临时性的文件和数据&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;命名规范我觉得rails的Convention over configuration做的相当完美，我们也遵循这个原则：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;所有的model类似XxxModel.php(第一个字母大写)，在数据库中相应的表名为xxxs（小写、复数）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;所有的controller类似XxxsController.php（第一个字母大写、复数）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;所有的view类似xxxs/view.php。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;例如网站用户(user)，其对应的mvc分别为UserModel,views/users/profile.php,UsersController。表名为users。&lt;/p&gt;

&lt;p&gt;####Web服务器配置
如果我们使用apache的虚拟主机，配置如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;VirtualHost *:80&amp;gt;
	ServerName youly.com
	RewriteEngine On
	RewriteRule ^/(.*)$ http://www.youly.com/$1 [L,R]
&amp;lt;/VirtualHost&amp;gt;

&amp;lt;VirtualHost *:80&amp;gt;
    ServerName www.youly.com
    ServerAlias *.youly.com
    DocumentRoot /path/to/public
    &amp;lt;Directory &quot;/path/to/public&quot;&amp;gt;
    &amp;lt;/Directory&amp;gt;
    RewriteEngine on
    RewriteRule ^/(assets\/.*)$ /$1 [L] 
    RewriteRule ^/(.*)$ /index.php [L] 
&amp;lt;/VirtualHost&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的重写规则指定除了public目录之外所有的请求都重定向到public目录下的index.php文件。可&lt;a href=&quot;http://www.yourhtmlsource.com/sitemanagement/urlrewriting.html&quot;&gt;点此&lt;/a&gt;了解apache的重写规则。打开index.php文件，我们可以看到如下的两行代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Dispatcher::getInstance()-&amp;gt;dispatch();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个文件很简短，只有两行。注意它并没有以?&amp;gt;结尾，主要是为了避免在我们的输出中注入多余的空格。那么Dispatcher是什么？它来自哪里？&lt;/p&gt;

&lt;p&gt;####php配置
ROOT为网站根目录。打开php.ini并设置auto_prepend_file=ROOT/config/prepend.php，这样每次执行用户请求的php文件前php内核将先执行prepend.php。打开prepend.php文件，我们可以看到：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;define('DEVELOPMENT_ENVIRONMENT', true);
define('DS', DIRECTORY_SEPARATOR);
define('ROOT', '/Users/meituan-it/dev/php-mvc');
define('APP_PATH', ROOT . DS . 'app');
define('URI', isset($_SERVER['REQUEST_URI']) ? urldecode($_SERVER['REQUEST_URI']) : '');
define('DB_HOST', '127.0.0.1:3306');
define('DB_USER','root');
define('DB_PASSWORD','123');
define('DB_NAME','youly');

set_include_path(ROOT . DS . 'lib' . PATH_SEPARATOR . get_include_path());

function __autoload($class) {
    $path = sprintf('%s/lib/%s.php', ROOT, $class);
	if(class_exists($class) || interface_exists($class)) {
        return true;
    } else if(file_exists($path)) {
        include_once($path);
        return true;
    } else if(substr($class, -5) == 'Model') {
        $path = sprintf('%s/models/%s.php', APP_PATH, $class);
	} else if(substr($class, -10) == 'Controller') {
		$path = sprintf('%s/controllers/%s.php', APP_PATH, $class);
	} else if (substr($class, -6) == 'Helper') {
		$path = sprintf('%s/helpers/%s.php', APP_PATH, $class);
    }
    if(file_exists($path)) {
        include_once($path);
        return true;
    }
	return false;
}

function setReporting() {
	if (DEVELOPMENT_ENVIRONMENT == true) {
	    error_reporting(E_ALL);
	    ini_set('display_errors','On');
	} else {
	    error_reporting(E_ALL);
	    ini_set('display_errors','Off');
	    ini_set('log_errors', 'On');
	    ini_set('error_log', ROOT.DS.'tmp'.DS.'logs'.DS.'error.log');
	}
}

setReporting();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里重写了php原有的__autoload函数，使得它能自动加载我们自己定义的类。setReporting函数是为了方便我们调试。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;第一个类&lt;/h4&gt;

&lt;p&gt;我们的第一个类Dispatcher，负责分发从前端传来的请求。打开lib/Dispatcher.php文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Dispatcher
{
    protected static $front;
    const URI_REGEXP = '/^\/([^\d\?\/\\][^\/]*?)?(?:\/([^\d\?\/\\][^\/]*?))?(?:\/([^\?]+?))?(?:\/\?.*)?$/s';

	public static function getInstance()
	{
		if(!isset(self::$front))
		{
			self::$front = new self();
		}
		return self::$front;
	}

	public static function dispatch()
    {
        if(!preg_match(self::URI_REGEXP, URI, $urlArray)) {
            return BaseController::page404();
        }
        $class = isset($urlArray[1]) &amp;amp;&amp;amp; !empty($urlArray[1]) ? $urlArray[1] : 'index';
        $action = isset($urlArray[2]) &amp;amp;&amp;amp; !empty($urlArray[2]) ? $urlArray[2] : 'default';
        if(isset($urlArray[3])) {
            $arr = explode('/', $urlArray[3]);
            foreach($arr as $k =&amp;gt; $v) {
                $arr[$k] = trim(urldecode($v));
            }
            $args = $arr;
        } else {
            $args = array();
        }
        //var_dump($controllerName, $action, $urlArray, $args);
        $method = ucwords($action);
		if(strcasecmp($_SERVER['REQUEST_METHOD'], 'POST') === 0) {
			$method = 'actPost' . $action;
		} else {
			$method = 'act' . $action;
		}

		$controller = ucwords($class) . 'Controller';
        $model = ucwords($class) . 'Model';
        $view = $class;
		$controllerObj = new $controller($model, $view, $action);

		if ((int)method_exists($controller, $method)) {
			call_user_func_array(array($controllerObj, $method), $args);
			$controllerObj-&amp;gt;renderTemplate();
		} else {
			return BaseController::page404();
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个类的主要函数是dispatch，由它来负责分发请求。处理的url类似 &lt;strong&gt;youly.com/controllerName/actionName/queryString&lt;/strong&gt;。关于这个正则表达式的分析看&lt;a href=&quot;/2013/07/18/php-regular-expression-greedy-or-nongreedy&quot;&gt;这篇文章&lt;/a&gt;。根据url中的控制器和动作，框架构造一个继承自BaseController的子类来处理具体的请求。&lt;/p&gt;

&lt;h4 id=&quot;controller&quot;&gt;Controller&lt;/h4&gt;

&lt;p&gt;打来文件lib/BaseController.php:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BaseController {
     
    protected $_model;
    protected $_action;
    protected $_view;
 
    public function __construct($model, $view, $action) {
         
        $this-&amp;gt;_action = $action;
        $this-&amp;gt;_model = $model;
        $this-&amp;gt;_view = new View($view,$action);
    }
 
    public function set($name,$value) {
        $this-&amp;gt;_view-&amp;gt;set($name,$value);
    }
 
    public static function page404()
    {
	    echo '404 NOT FOUND!';
	    return false;
    }
    
    public function renderTemplate()
    {
	    $this-&amp;gt;_view-&amp;gt;render();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Controller负责从Mode里取数据，并通过视图呈现出来。&lt;/p&gt;

&lt;h4 id=&quot;view&quot;&gt;View&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class View {
     
    protected $variables = array();
    protected $_view;
    protected $_action;
     
    function __construct($view,$action) {
        $this-&amp;gt;_view = $view;
        $this-&amp;gt;_action = $action;
    }
    //模板变量 
    function set($name,$value) {
        $this-&amp;gt;variables[$name] = $value;
    }
 
    function render() {
        extract($this-&amp;gt;variables);
        if(file_exists(APP_PATH . DS . 'views' . DS . 'common' . DS . 'header.php')) {
        	include (APP_PATH . DS . 'views' . DS . 'common' . DS . 'header.php');
        }
 	    if(file_exists(APP_PATH. DS . 'views' . DS . $this-&amp;gt;_view . DS . $this-&amp;gt;_action . '.php')) {
        	include (APP_PATH. DS . 'views' . DS . $this-&amp;gt;_view . DS . $this-&amp;gt;_action . '.php');
 	    } else {
		    BaseController::page404();
 	    }
        if(file_exists(APP_PATH . DS . 'views' . DS . 'common' . DS . 'footer.php')) {
        	include (APP_PATH . DS . 'views' . DS . 'common' . DS . 'footer.php');
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个文件主要负责展开模板变量并包含对应的模板文件。&lt;/p&gt;

&lt;h4 id=&quot;model&quot;&gt;Model&lt;/h4&gt;

&lt;p&gt;Model，数据模型，负责存取数据。一般的Web框架中都会有对象关系映射（ORM)，即一个Model类属性对应数据库记录的一列。为了简单起见，先不考虑这个。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class BaseModel extends SQLQuery
{
    protected $_table;

    function __construct() {

        $this-&amp;gt;connect(DB_HOST,DB_USER,DB_PASSWORD,DB_NAME);
        $this-&amp;gt;_table = strtolower(substr(get_class($this), 0, -5));
    }

    function __destruct() {
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个类继承自SQLQuery，它封装了数据库连接的逻辑：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class SQLQuery {
    protected $_db;
    protected $_result;

    /** Connects to database **/

    function connect($address, $account, $pwd, $name) {
        $this-&amp;gt;_db = @mysql_connect($address, $account, $pwd);
        if ($this-&amp;gt;_db != 0) {
            if (mysql_select_db($name, $this-&amp;gt;_db)) {
                return 1;
            }
            else {
                return 0;
            }
        }
        else {
            return 0;
        }
    }

    /** Disconnects from database **/

    function disconnect() {
        if (@mysql_close($this-&amp;gt;_db) != 0) {
            return 1;
        }  else {
            return 0;
        }
    }
    
    function selectAll() {
    	$query = 'select * from `'.$this-&amp;gt;_table.'`';
    	return $this-&amp;gt;query($query);
    }

	function query($query, $singleResult = 0) {

		$this-&amp;gt;_result = mysql_query($query, $this-&amp;gt;_db);
		$result = array();
		$field = array();
		$tempResults = array();
		$numOfFields = mysql_num_fields($this-&amp;gt;_result);
		for ($i = 0; $i &amp;lt; $numOfFields; ++$i) {
		    array_push($field,mysql_field_name($this-&amp;gt;_result, $i));
		}

		
        while ($row = mysql_fetch_row($this-&amp;gt;_result)) {
            for ($i = 0;$i &amp;lt; $numOfFields; ++$i) {
                $tempResults[$field[$i]] = $row[$i];
            }
            if ($singleResult == 1) {
                mysql_free_result($this-&amp;gt;_result);
                return $tempResults;
            }
            array_push($result,$tempResults);
        }
        mysql_free_result($this-&amp;gt;_result);
        return($result);
	}
    /** 释放数据库连接 **/
    function freeResult() {
        mysql_free_result($this-&amp;gt;_result);
    }
    /** 返回错误字符串 **/
    function getError() {
        return mysql_error($this-&amp;gt;_db);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-1&quot;&gt;实例&lt;/h4&gt;
&lt;p&gt;有了上面的mvc，就可以开始做简单的开发了：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class IndexController extends BaseController
{
	public function actDefault($defaultArg = null)
    {
        $this-&amp;gt;set('defaultArg', $defaultArg);
        $message = new MessageModel();
        $msgs = $message-&amp;gt;selectAll();
        $this-&amp;gt;set('messages', $msgs);
	}
}

echo is_null($defaultArg) ? 'hello world' : 'hello ' . $defaultArg;

echo '&amp;lt;h3&amp;gt;留言板&amp;lt;/h3&amp;gt;
&amp;lt;table border=0&amp;gt;
&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;内容&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;时间&amp;lt;/th&amp;gt;';
foreach($messages as $msg)
{
	echo '&amp;lt;tr&amp;gt;';
	echo '&amp;lt;td&amp;gt;', $msg['msg'], '&amp;lt;/td&amp;gt;&amp;lt;td&amp;gt;', date('Y-m-d H:i:s', $msg['addtime']), '&amp;lt;/td&amp;gt;';
	echo '&amp;lt;/tr&amp;gt;';
}
echo '&amp;lt;/table&amp;gt;';

class MessageModel extends BaseModel
{
	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在浏览器中访问 www.youly.com,如下&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/mvc-example.png&quot; alt=&quot;example&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;参考&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;1、&lt;a href=&quot;http://anantgarg.com/2009/03/13/write-your-own-php-mvc-framework-part-1/&quot;&gt;http://anantgarg.com/2009/03/13/write-your-own-php-mvc-framework-part-1/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://www.yourhtmlsource.com/sitemanagement/urlrewriting.html&quot;&gt;Apache rewrite rules&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://youly.github.io/2013/07/20/make-your-own-php-mvc-framework</link>
                <guid>http://youly.github.io/2013/07/20/make-your-own-php-mvc-framework</guid>
                <pubDate>2013-07-20T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>php正则表达式-非贪婪匹配和递归匹配</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;贪婪匹配与非贪婪匹配&lt;/h3&gt;

&lt;p&gt;php中所有的正则表达式默认都是贪婪的，即一个标识符（如*）会尽可能多地匹配字符。&lt;/p&gt;

&lt;p&gt;举个例子，如模式p*，它先匹配一个p，然后是0个或者多个字符。对于字符串“php”。在贪婪模式下，它能找到一个匹配，首先它匹配一个p，接着它匹配hp。而在非贪婪模式下，它能找到两个匹配。开始他能匹配p然后h，但是接下来它并不是继续匹配p，而是把最后一个p留下，当做下一次匹配的开始。看下面的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//preg_match_all函数输出匹配到的个数
$match = array();
print preg_match_all('/p.*/', &quot;php&quot;, $match);  // 贪婪，输出1
print preg_match_all('/p.*?/', &quot;php&quot;, $match); // 非贪婪，输出2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;贪婪匹配也叫最大匹配，非贪婪匹配又名最小匹配。再看另外一个例子：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;贪婪模式下：
$html = '&amp;lt;b&amp;gt;I am bold.&amp;lt;/b&amp;gt; &amp;lt;i&amp;gt;I am italic.&amp;lt;/i&amp;gt; &amp;lt;b&amp;gt;I am also bold.&amp;lt;/b&amp;gt;';
preg_match_all('/&amp;lt;b&amp;gt;(.+)&amp;lt;/b&amp;gt;/', $html, $bolds);
print_r($bolds[1]);
Array
(
    [0] =&amp;gt; I am bold.&amp;lt;/b&amp;gt; &amp;lt;i&amp;gt;I am italic.&amp;lt;/i&amp;gt; &amp;lt;b&amp;gt;I am also bold.

)

非贪婪模式下：
$html = '&amp;lt;b&amp;gt;I am bold.&amp;lt;/b&amp;gt; &amp;lt;i&amp;gt;I am italic.&amp;lt;/i&amp;gt; &amp;lt;b&amp;gt;I am also bold.&amp;lt;/b&amp;gt;';
preg_match_all('/&amp;lt;b&amp;gt;(.+?)&amp;lt;/b&amp;gt;/', $html, $bolds);
print_r($bolds[1]);
Array
(
    [0] =&amp;gt; I am bold.
    [1] =&amp;gt; I am also bold.
)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;再来看一个更复杂的，为了方便阅读拆分成多段：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    const URL_REGEXP = '/
    	^(\/[\d]+)?
    	\/([^\d\?\/\\][^\/]*?)?
    	(?:\/([^\?\/\\][^\/]*?))?
    	(?:\/([^\?]+?))?
    	(?:\/?\?.*)?
    $/is';
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个正则表达式的状态转换图是：
&lt;img src=&quot;/assets/images/regularexperssion.jpg&quot; alt=&quot;状态转换图&quot; /&gt;&lt;/p&gt;

&lt;p&gt;假设带匹配的字符串 $str = /a/b/,通过上面的正则表达式匹配到的结果是什么呢？&lt;/p&gt;

&lt;p&gt;?:表示只匹配不捕获，也就是不会出现在结果中。对于$str,它的匹配结果如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;array(5) {
  [0]=&amp;gt;
  string(5) &quot;/a/b/&quot;
  [1]=&amp;gt;
  string(0) &quot;&quot;
  [2]=&amp;gt;
  string(1) &quot;a&quot;
  [3]=&amp;gt;
  string(0) &quot;&quot; //这个为什么是空呢？
  [4]=&amp;gt;
  string(2) &quot;b/&quot;
} 刚开始没搞懂为什么匹配到的结果是这个，后来和同事在邮件中讨论才搞明白，一下是邮件原文：
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;img src=&quot;/assets/images/regularexperssion2.png&quot; alt=&quot;正则表达式&quot; /&gt;
含“?:”的括号中表达式只匹配不捕获（non-capturing subpatterns），&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;匹配“/a”后分析表达式       (?:\/([^\?\/\][^\/]*?))?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;根据默认的贪婪原则，括号后“?”先尝试匹配1次括号中表达式&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;根据非贪婪原则，”*?”先尝试匹配0次”[^\/]”，即匹配”/b”，但这样匹配后，后面的正则表达式无法成功匹配剩下的”/”，所以回溯&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;”*?”尝试匹配1次”[^\/]”，无法匹配 “/b/”，。。。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;“匹配1次括号中表达式”失败，进行回溯&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;括号后“?”尝试匹配0次，即该表达式匹配空字符串，其中红色部分为不含“?:”的第三个括号，所以匹配结果中第3个为空（去掉“?:”后该表达式两个括号结果都为空）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;感觉贪婪、非贪婪匹配纠结的地方是 需要在整个正则表达式成功匹配的前提下 使子模式尽可能多（少）的匹配，否则需要回溯，直到匹配成功&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;递归匹配&lt;/h3&gt;

&lt;p&gt;递归匹配用符号(?R)来表示，指正则表达式本身。php文档里的&lt;a href=&quot;http://php.net/manual/en/regexp.reference.recursive.php&quot;&gt;描述&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Consider the problem of matching a string in parentheses, allowing for unlimited nested parentheses. Without the use of recursion, the best that can be done is to use a pattern that matches up to some fixed depth of nesting.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;看下面的代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$str = '{&quot;name&quot;:&quot;percent_param&quot;, &quot;default&quot;:{&quot;24小时回复率&quot;:[&quot;24小时回复量&quot;,&quot;售后平台维权量&quot;]}}';
preg_match_all(&quot;/{[^{}]*((?R)*)}/&quot;, $str, $t);
var_dump($t);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;打印结果：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;array(2) {
  [0]=&amp;gt;
  array(1) {
    [0]=&amp;gt;
    string(103) &quot;{&quot;name&quot;:&quot;percent_param&quot;, &quot;default&quot;:{&quot;24小时回复率&quot;:[&quot;24小时回复量&quot;,&quot;售后平台维权量&quot;]}}&quot;
  }
  [1]=&amp;gt;
  array(1) {
    [0]=&amp;gt;
    string(67) &quot;{&quot;24小时回复率&quot;:[&quot;24小时回复量&quot;,&quot;售后平台维权量&quot;]}&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里要理解为什么$t[1] = {“24小时回复率”:[“24小时回复量”,”售后平台维权量”]}。如果把正则表达式改成”/{[^{}]&lt;em&gt;(?R&lt;/em&gt;)}/”呢？结果就很明显了，$t[1]是正则表达式匹配迭代中最后一次的捕获结果。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;span style=&quot;color:red&quot;&gt;PREG_PATTERN_ORDER:Orders results so that $matches[0] is an array of full pattern matches, $matches[1] is an array of strings matched by the first parenthesized subpattern, and so on.If no order flag is given, PREG_PATTERN_ORDER is assumed.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-2&quot;&gt;参考链接&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;http://docstore.mik.ua/orelly/webprog/pcook/ch13_05.htm&quot;&gt;Choosing Greedy or Nongreedy Matches&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://iregex.org/blog/recursive-regex-in-php.html&quot;&gt;PHP中的递归正则&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://youly.github.io/2013/07/18/php-regular-expression-greedy-or-nongreedy</link>
                <guid>http://youly.github.io/2013/07/18/php-regular-expression-greedy-or-nongreedy</guid>
                <pubDate>2013-07-18T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>负载均衡算法一览</title>
                <description>&lt;p&gt;在服务器集群中，为了避免某一台服务器因过载而崩溃，除了每台服务器限定了最大连接数外，还对服务器的负载进行了均分。本文介绍了几个常见的负载均衡算法。&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;随机&lt;/h4&gt;
&lt;p&gt;通过随机数生成算法从服务器组中选取一个，然后把请求发送给它。&lt;/p&gt;

&lt;h4 id=&quot;section-1&quot;&gt;轮询&lt;/h4&gt;
&lt;p&gt;所有的服务器组成一个队列，不管连接数、响应时间，从队列首取出一个，然后放到队尾，不断循环。最终把所有的请求平均分给所有的服务器。适用于服务器性能差异不大的情况。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;加权轮询&lt;/h4&gt;
&lt;p&gt;给每台服务器加一个权重值，高权重的服务器将被分配高比例的连接。假设有一组服务器S = {S0, S1, …, Sn-1}，W(Si)表示服务器Si的权值，一个指示变量i表示上一次选择的服务器，指示变量cw表示当前调度的权值，max(S)表示集合S中所有服务器的最大权值，gcd(S)表示集合S中所有服务器权值的最大
公约数。变量i初始化为-1，cw初始化为零。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;while (true) {
  i = (i + 1) mod n;
  if (i == 0) {
     cw = cw - gcd(S);
     if (cw &amp;lt;= 0) {
       cw = max(S);
       if (cw == 0)
         return NULL;
     }
  }
  if (W(Si) &amp;gt;= cw)
    return Si;
} 此算法的思想是先把请求分配给高权重的机器，然后降低其权值，直到有一个机器的权值小于它，才把请求分配给权值第二大的机器。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-3&quot;&gt;最少连接&lt;/h4&gt;
&lt;p&gt;由于各服务器处理请求的时间不同，因此同一时刻各服务器的当前连接数都不同。此算法将到来的请求分配给当前连接数最少的服务器。处理速度越快的服务器将被分配到越多的连接。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;哈希&lt;/h4&gt;
&lt;p&gt;可以用来hash的输入有很多，比如源IP地址，URL，cookie&lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;http://stblog.baidu-tech.com/?p=2027&quot;&gt;解析nginx负载均衡&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2、&lt;a href=&quot;http://zh.linuxvirtualserver.org/node/37&quot;&gt;加权轮叫调度（Weighted Round-Robin Scheduling）&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://youly.github.io/2013/07/09/load-blance-algorithm</link>
                <guid>http://youly.github.io/2013/07/09/load-blance-algorithm</guid>
                <pubDate>2013-07-09T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>开会的效率</title>
                <description>&lt;h3 id=&quot;section&quot;&gt;为什么要开会&lt;/h3&gt;

&lt;p&gt;开会是工作中与人沟通的一种方式，我们渴望通过会议来传递信息从而达成某种目的。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;解决问题还是制造问题&lt;/h3&gt;

&lt;p&gt;高效的会议应该主题清晰、开门见山、简明扼要、言之有物。否则以解决问题为目的的会议反而变成制造问题的深渊。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;值得去做么，成本有多大&lt;/h3&gt;

&lt;p&gt;网上有这么一个公式：&lt;br /&gt;
&amp;gt;会议的&lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E6%9C%BA%E4%BC%9A%E6%88%90%E6%9C%AC&quot;&gt;机会成本&lt;/a&gt;=每小时平均工资的3倍×2×开会人数×开会时间(小时)&lt;br /&gt;
平均工资乘以3，是因为参会人员创造的劳动产值通常是平均工资的3倍;&lt;br /&gt;
乘以2是因为参加会议要中断日常工作，因此损失要以2倍来计算;  &lt;br /&gt;
可以去&lt;a href=&quot;http://www.effectivemeetings.com/diversions/meetingcost.asp&quot;&gt;这个网站&lt;/a&gt;计算你开会的成本。&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;#### 【附】会议的类型&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;按照会议的目的不同，可以将会议形式分为五种类型。谈判会议：用于解决争端和冲突，目的在于经过讨论达成一致或谅解；报告会议：信息往往是单向流动，不允许讨论，否则会影响信息的有效传递；解决问题会议：要求充分发挥参会人员的主观能动性，使问题得以有效的解决；制定决策会议：只限于特殊人员参与，组织严密。参与者必须深刻理解决策并对决策承担责任；收集、发布、交流信息会议：发布消息，发表意见，了解对消息、意见的反应。此类会议鼓励讨论与提问。其实，企业的会议经常是几种会议的整合。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-3&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;http://wiki.mbalib.com/wiki/%E6%8F%90%E9%AB%98%E4%BC%9A%E8%AE%AE%E6%95%88%E7%8E%87%E6%B3%95&quot;&gt;http://wiki.mbalib.com/wiki/%E6%8F%90%E9%AB%98%E4%BC%9A%E8%AE%AE%E6%95%88%E7%8E%87%E6%B3%95&lt;/a&gt;&lt;/p&gt;
</description>
                <link>http://youly.github.io/2013/07/06/how-to-make-a-conference</link>
                <guid>http://youly.github.io/2013/07/06/how-to-make-a-conference</guid>
                <pubDate>2013-07-06T00:00:00+08:00</pubDate>
        </item>

        <item>
                <title>像XX一样博客</title>
                <description>&lt;p&gt;看到这篇&lt;a href=&quot;http://tom.preston-werner.com/2008/11/17/blogging-like-a-hacker.html&quot;&gt;博客&lt;/a&gt;后，终于在决定要在github上写自己的文章了，虽然还没想好在这里要写些什么，也算是一个开始。&lt;/p&gt;

&lt;p&gt;之前在点点上开着两个博客，一个关于生活，一个关于技术，但大都是一些别人的东西或者一些小笔记，没过多久就没再更新了。不知道要干什么，觉得这些根本没有意义吧。&lt;/p&gt;

&lt;p&gt;工作后自己的时间少了，又迷上了游戏(lol)，一天过去恍惚什么也没有留下。想找找时间学习，貌似只是想想罢了，并没有付诸实践，时间仍如流水。&lt;/p&gt;

&lt;p&gt;开这个博客，希望每天打开电脑的时候，能给自己一点提醒，争取每天进步一点点。&lt;/p&gt;

</description>
                <link>http://youly.github.io/2013/07/04/finally-i-hava-a-blog-now</link>
                <guid>http://youly.github.io/2013/07/04/finally-i-hava-a-blog-now</guid>
                <pubDate>2013-07-04T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
